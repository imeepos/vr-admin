{"version":3,"file":"index-DVsF2acd.js","sources":["../../frontend/node_modules/three-mesh-bvh/src/objects/MeshBVHHelper.js","../../frontend/node_modules/three-mesh-bvh/src/debug/Debug.js","../../frontend/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js","../../frontend/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/VertexAttributeTexture.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/MeshBVHUniformStruct.js","../../frontend/node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/glsl/common_functions.glsl.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_distance_functions.glsl.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_ray_functions.glsl.js","../../frontend/node_modules/three-mesh-bvh/src/gpu/glsl/bvh_struct_definitions.glsl.js","../../frontend/node_modules/three-mesh-bvh/src/index.js"],"sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry, Mesh, Matrix4 } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst boundingBox = /* @__PURE__ */ new Box3();\nconst matrix = /* @__PURE__ */ new Matrix4();\n\nclass MeshBVHRootHelper extends Object3D {\n\n\tget isMesh() {\n\n\t\treturn ! this.displayEdges;\n\n\t}\n\n\tget isLineSegments() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tget isLine() {\n\n\t\treturn this.displayEdges;\n\n\t}\n\n\tgetVertexPosition( ...args ) {\n\n\t\t// implement this function so it works with Box3.setFromObject\n\t\treturn Mesh.prototype.getVertexPosition.call( this, ...args );\n\n\t}\n\n\tconstructor( bvh, material, depth = 10, group = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.material = material;\n\t\tthis.geometry = new BufferGeometry();\n\t\tthis.name = 'MeshBVHRootHelper';\n\t\tthis.depth = depth;\n\t\tthis.displayParents = false;\n\t\tthis.bvh = bvh;\n\t\tthis.displayEdges = true;\n\t\tthis._group = group;\n\n\t}\n\n\traycast() {}\n\n\tupdate() {\n\n\t\tconst geometry = this.geometry;\n\t\tconst boundsTree = this.bvh;\n\t\tconst group = this._group;\n\t\tgeometry.dispose();\n\t\tthis.visible = false;\n\t\tif ( boundsTree ) {\n\n\t\t\t// count the number of bounds required\n\t\t\tconst targetDepth = this.depth - 1;\n\t\t\tconst displayParents = this.displayParents;\n\t\t\tlet boundsCount = 0;\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\n\n\t\t\t\tif ( depth >= targetDepth || isLeaf ) {\n\n\t\t\t\t\tboundsCount ++;\n\t\t\t\t\treturn true;\n\n\t\t\t\t} else if ( displayParents ) {\n\n\t\t\t\t\tboundsCount ++;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\t// fill in the position buffer with the bounds corners\n\t\t\tlet posIndex = 0;\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\n\n\t\t\t\tconst terminate = depth >= targetDepth || isLeaf;\n\t\t\t\tif ( terminate || displayParents ) {\n\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\n\n\t\t\t\t\tconst { min, max } = boundingBox;\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\n\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\n\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\n\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\n\n\t\t\t\t\t\t\t\tposIndex += 3;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\treturn terminate;\n\n\t\t\t\t}\n\n\t\t\t}, group );\n\n\t\t\tlet indexArray;\n\t\t\tlet indices;\n\t\t\tif ( this.displayEdges ) {\n\n\t\t\t\t// fill in the index buffer to point to the corner points\n\t\t\t\tindices = new Uint8Array( [\n\t\t\t\t\t// x axis\n\t\t\t\t\t0, 4,\n\t\t\t\t\t1, 5,\n\t\t\t\t\t2, 6,\n\t\t\t\t\t3, 7,\n\n\t\t\t\t\t// y axis\n\t\t\t\t\t0, 2,\n\t\t\t\t\t1, 3,\n\t\t\t\t\t4, 6,\n\t\t\t\t\t5, 7,\n\n\t\t\t\t\t// z axis\n\t\t\t\t\t0, 1,\n\t\t\t\t\t2, 3,\n\t\t\t\t\t4, 5,\n\t\t\t\t\t6, 7,\n\t\t\t\t] );\n\n\t\t\t} else {\n\n\t\t\t\tindices = new Uint8Array( [\n\n\t\t\t\t\t// X-, X+\n\t\t\t\t\t0, 1, 2,\n\t\t\t\t\t2, 1, 3,\n\n\t\t\t\t\t4, 6, 5,\n\t\t\t\t\t6, 7, 5,\n\n\t\t\t\t\t// Y-, Y+\n\t\t\t\t\t1, 4, 5,\n\t\t\t\t\t0, 4, 1,\n\n\t\t\t\t\t2, 3, 6,\n\t\t\t\t\t3, 7, 6,\n\n\t\t\t\t\t// Z-, Z+\n\t\t\t\t\t0, 2, 4,\n\t\t\t\t\t2, 6, 4,\n\n\t\t\t\t\t1, 5, 3,\n\t\t\t\t\t3, 5, 7,\n\n\t\t\t\t] );\n\n\t\t\t}\n\n\t\t\tif ( positionArray.length > 65535 ) {\n\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\n\n\t\t\t} else {\n\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\n\n\t\t\t}\n\n\t\t\tconst indexLength = indices.length;\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\n\n\t\t\t\tconst posOffset = i * 8;\n\t\t\t\tconst indexOffset = i * indexLength;\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\n\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the geometry\n\t\t\tgeometry.setIndex(\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\n\t\t\t);\n\t\t\tgeometry.setAttribute(\n\t\t\t\t'position',\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\n\t\t\t);\n\t\t\tthis.visible = true;\n\n\t\t}\n\n\t}\n\n}\n\nclass MeshBVHHelper extends Group {\n\n\tget color() {\n\n\t\treturn this.edgeMaterial.color;\n\n\t}\n\n\tget opacity() {\n\n\t\treturn this.edgeMaterial.opacity;\n\n\t}\n\n\tset opacity( v ) {\n\n\t\tthis.edgeMaterial.opacity = v;\n\t\tthis.meshMaterial.opacity = v;\n\n\t}\n\n\tconstructor( mesh = null, bvh = null, depth = 10 ) {\n\n\t\t// handle bvh, depth signature\n\t\tif ( mesh instanceof MeshBVH ) {\n\n\t\t\tdepth = bvh || 10;\n\t\t\tbvh = mesh;\n\t\t\tmesh = null;\n\n\t\t}\n\n\t\t// handle mesh, depth signature\n\t\tif ( typeof bvh === 'number' ) {\n\n\t\t\tdepth = bvh;\n\t\t\tbvh = null;\n\n\t\t}\n\n\t\tsuper();\n\n\t\tthis.name = 'MeshBVHHelper';\n\t\tthis.depth = depth;\n\t\tthis.mesh = mesh;\n\t\tthis.bvh = bvh;\n\t\tthis.displayParents = false;\n\t\tthis.displayEdges = true;\n\t\tthis.objectIndex = 0;\n\t\tthis._roots = [];\n\n\t\tconst edgeMaterial = new LineBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tconst meshMaterial = new MeshBasicMaterial( {\n\t\t\tcolor: 0x00FF88,\n\t\t\ttransparent: true,\n\t\t\topacity: 0.3,\n\t\t\tdepthWrite: false,\n\t\t} );\n\n\t\tmeshMaterial.color = edgeMaterial.color;\n\n\t\tthis.edgeMaterial = edgeMaterial;\n\t\tthis.meshMaterial = meshMaterial;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tlet bvh = this.bvh || mesh.geometry.boundsTree || null;\n\t\tif ( mesh.isBatchedMesh && mesh.boundsTrees && ! bvh ) {\n\n\t\t\t// get the bvh from a batchedMesh if not provided\n\t\t\t// TODO: we should have an official way to get the geometry index cleanly\n\t\t\tconst drawInfo = mesh._drawInfo[ this.objectIndex ];\n\t\t\tif ( drawInfo ) {\n\n\t\t\t\tbvh = mesh.boundsTrees[ drawInfo.geometryIndex ] || bvh;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\n\t\twhile ( this._roots.length > totalRoots ) {\n\n\t\t\tconst root = this._roots.pop();\n\t\t\troot.geometry.dispose();\n\t\t\tthis.remove( root );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\n\n\t\t\tconst { depth, edgeMaterial, meshMaterial, displayParents, displayEdges } = this;\n\n\t\t\tif ( i >= this._roots.length ) {\n\n\t\t\t\tconst root = new MeshBVHRootHelper( bvh, edgeMaterial, depth, i );\n\t\t\t\tthis.add( root );\n\t\t\t\tthis._roots.push( root );\n\n\t\t\t}\n\n\t\t\tconst root = this._roots[ i ];\n\t\t\troot.bvh = bvh;\n\t\t\troot.depth = depth;\n\t\t\troot.displayParents = displayParents;\n\t\t\troot.displayEdges = displayEdges;\n\t\t\troot.material = displayEdges ? edgeMaterial : meshMaterial;\n\t\t\troot.update();\n\n\t\t}\n\n\t}\n\n\tupdateMatrixWorld( ...args ) {\n\n\t\tconst mesh = this.mesh;\n\t\tconst parent = this.parent;\n\n\t\tif ( mesh !== null ) {\n\n\t\t\tmesh.updateWorldMatrix( true, false );\n\n\t\t\tif ( parent ) {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( parent.matrixWorld )\n\t\t\t\t\t.invert()\n\t\t\t\t\t.multiply( mesh.matrixWorld );\n\n\t\t\t} else {\n\n\t\t\t\tthis.matrix\n\t\t\t\t\t.copy( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\t// handle batched and instanced mesh bvhs\n\t\t\tif ( mesh.isInstancedMesh || mesh.isBatchedMesh ) {\n\n\t\t\t\tmesh.getMatrixAt( this.objectIndex, matrix );\n\t\t\t\tthis.matrix.multiply( matrix );\n\n\t\t\t}\n\n\t\t\tthis.matrix.decompose(\n\t\t\t\tthis.position,\n\t\t\t\tthis.quaternion,\n\t\t\t\tthis.scale,\n\t\t\t);\n\n\t\t}\n\n\t\tsuper.updateMatrixWorld( ...args );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.depth = source.depth;\n\t\tthis.mesh = source.mesh;\n\t\tthis.bvh = source.bvh;\n\t\tthis.opacity = source.opacity;\n\t\tthis.color.copy( source.color );\n\n\t}\n\n\tclone() {\n\n\t\treturn new MeshBVHHelper( this.mesh, this.bvh, this.depth );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.edgeMaterial.dispose();\n\t\tthis.meshMaterial.dispose();\n\n\t\tconst children = this.children;\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tchildren[ i ].geometry.dispose();\n\n\t\t}\n\n\t}\n\n}\n\nexport class MeshBVHVisualizer extends MeshBVHHelper {\n\n\tconstructor( ...args ) {\n\n\t\tsuper( ...args );\n\n\t\tconsole.warn( 'MeshBVHVisualizer: MeshBVHVisualizer has been deprecated. Use MeshBVHHelper, instead.' );\n\n\t}\n\n}\n\nexport { MeshBVHHelper };\n","import { Box3, Vector3 } from 'three';\nimport { TRAVERSAL_COST, TRIANGLE_INTERSECT_COST } from '../core/Constants.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { isSharedArrayBufferSupported } from '../utils/BufferUtils.js';\n\nconst _box1 = /* @__PURE__ */ new Box3();\nconst _box2 = /* @__PURE__ */ new Box3();\nconst _vec = /* @__PURE__ */ new Vector3();\n\n// https://stackoverflow.com/questions/1248302/how-to-get-the-size-of-a-javascript-object\nfunction getPrimitiveSize( el ) {\n\n\tswitch ( typeof el ) {\n\n\t\tcase 'number':\n\t\t\treturn 8;\n\t\tcase 'string':\n\t\t\treturn el.length * 2;\n\t\tcase 'boolean':\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\n\t}\n\n}\n\nfunction isTypedArray( arr ) {\n\n\tconst regex = /(Uint|Int|Float)(8|16|32)Array/;\n\treturn regex.test( arr.constructor.name );\n\n}\n\nfunction getRootExtremes( bvh, group ) {\n\n\tconst result = {\n\t\tnodeCount: 0,\n\t\tleafNodeCount: 0,\n\n\t\tdepth: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\ttris: {\n\t\t\tmin: Infinity, max: - Infinity\n\t\t},\n\t\tsplits: [ 0, 0, 0 ],\n\t\tsurfaceAreaScore: 0,\n\t};\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offsetOrSplit, count ) => {\n\n\t\tconst l0 = boundingData[ 0 + 3 ] - boundingData[ 0 ];\n\t\tconst l1 = boundingData[ 1 + 3 ] - boundingData[ 1 ];\n\t\tconst l2 = boundingData[ 2 + 3 ] - boundingData[ 2 ];\n\n\t\tconst surfaceArea = 2 * ( l0 * l1 + l1 * l2 + l2 * l0 );\n\n\t\tresult.nodeCount ++;\n\t\tif ( isLeaf ) {\n\n\t\t\tresult.leafNodeCount ++;\n\n\t\t\tresult.depth.min = Math.min( depth, result.depth.min );\n\t\t\tresult.depth.max = Math.max( depth, result.depth.max );\n\n\t\t\tresult.tris.min = Math.min( count, result.tris.min );\n\t\t\tresult.tris.max = Math.max( count, result.tris.max );\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRIANGLE_INTERSECT_COST * count;\n\n\t\t} else {\n\n\t\t\tresult.splits[ offsetOrSplit ] ++;\n\n\t\t\tresult.surfaceAreaScore += surfaceArea * TRAVERSAL_COST;\n\n\t\t}\n\n\t}, group );\n\n\t// If there are no leaf nodes because the tree hasn't finished generating yet.\n\tif ( result.tris.min === Infinity ) {\n\n\t\tresult.tris.min = 0;\n\t\tresult.tris.max = 0;\n\n\t}\n\n\tif ( result.depth.min === Infinity ) {\n\n\t\tresult.depth.min = 0;\n\t\tresult.depth.max = 0;\n\n\t}\n\n\treturn result;\n\n}\n\nfunction getBVHExtremes( bvh ) {\n\n\treturn bvh._roots.map( ( root, i ) => getRootExtremes( bvh, i ) );\n\n}\n\nfunction estimateMemoryInBytes( obj ) {\n\n\tconst traversed = new Set();\n\tconst stack = [ obj ];\n\tlet bytes = 0;\n\n\twhile ( stack.length ) {\n\n\t\tconst curr = stack.pop();\n\t\tif ( traversed.has( curr ) ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\ttraversed.add( curr );\n\n\t\tfor ( let key in curr ) {\n\n\t\t\tif ( ! Object.hasOwn( curr, key ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tbytes += getPrimitiveSize( key );\n\n\t\t\tconst value = curr[ key ];\n\t\t\tif ( value && ( typeof value === 'object' || typeof value === 'function' ) ) {\n\n\t\t\t\tif ( isTypedArray( value ) ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( isSharedArrayBufferSupported() && value instanceof SharedArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else if ( value instanceof ArrayBuffer ) {\n\n\t\t\t\t\tbytes += value.byteLength;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( value );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tbytes += getPrimitiveSize( value );\n\n\t\t\t}\n\n\n\t\t}\n\n\t}\n\n\treturn bytes;\n\n}\n\nfunction validateBounds( bvh ) {\n\n\tconst geometry = bvh.geometry;\n\tconst depthStack = [];\n\tconst index = geometry.index;\n\tconst position = geometry.getAttribute( 'position' );\n\tlet passes = true;\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tdepth,\n\t\t\tisLeaf,\n\t\t\tboundingData,\n\t\t\toffset,\n\t\t\tcount,\n\t\t};\n\t\tdepthStack[ depth ] = info;\n\n\t\tarrayToBox( 0, boundingData, _box1 );\n\t\tconst parent = depthStack[ depth - 1 ];\n\n\t\tif ( isLeaf ) {\n\n\t\t\t// check triangles\n\t\t\tfor ( let i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\t\t\tconst triIndex = bvh.resolveTriangleIndex( i );\n\t\t\t\tlet i0 = 3 * triIndex;\n\t\t\t\tlet i1 = 3 * triIndex + 1;\n\t\t\t\tlet i2 = 3 * triIndex + 2;\n\n\t\t\t\tif ( index ) {\n\n\t\t\t\t\ti0 = index.getX( i0 );\n\t\t\t\t\ti1 = index.getX( i1 );\n\t\t\t\t\ti2 = index.getX( i2 );\n\n\t\t\t\t}\n\n\t\t\t\tlet isContained;\n\n\t\t\t\t_vec.fromBufferAttribute( position, i0 );\n\t\t\t\tisContained = _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i1 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\t_vec.fromBufferAttribute( position, i2 );\n\t\t\t\tisContained = isContained && _box1.containsPoint( _vec );\n\n\t\t\t\tconsole.assert( isContained, 'Leaf bounds does not fully contain triangle.' );\n\t\t\t\tpasses = passes && isContained;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\t// check if my bounds fit in my parents\n\t\t\tarrayToBox( 0, boundingData, _box2 );\n\n\t\t\tconst isContained = _box2.containsBox( _box1 );\n\t\t\tconsole.assert( isContained, 'Parent bounds does not fully contain child.' );\n\t\t\tpasses = passes && isContained;\n\n\t\t}\n\n\t} );\n\n\treturn passes;\n\n}\n\n// Returns a simple, human readable object that represents the BVH.\nfunction getJSONStructure( bvh ) {\n\n\tconst depthStack = [];\n\n\tbvh.traverse( ( depth, isLeaf, boundingData, offset, count ) => {\n\n\t\tconst info = {\n\t\t\tbounds: arrayToBox( 0, boundingData, new Box3() ),\n\t\t};\n\n\t\tif ( isLeaf ) {\n\n\t\t\tinfo.count = count;\n\t\t\tinfo.offset = offset;\n\n\t\t} else {\n\n\t\t\tinfo.left = null;\n\t\t\tinfo.right = null;\n\n\t\t}\n\n\t\tdepthStack[ depth ] = info;\n\n\t\t// traversal hits the left then right node\n\t\tconst parent = depthStack[ depth - 1 ];\n\t\tif ( parent ) {\n\n\t\t\tif ( parent.left === null ) {\n\n\t\t\t\tparent.left = info;\n\n\t\t\t} else {\n\n\t\t\t\tparent.right = info;\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn depthStack[ 0 ];\n\n}\n\nexport { estimateMemoryInBytes, getBVHExtremes, validateBounds, getJSONStructure };\n","// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nexport function convertRaycastIntersect( hit, object, raycaster ) {\n\n\tif ( hit === null ) {\n\n\t\treturn null;\n\n\t}\n\n\thit.point.applyMatrix4( object.matrixWorld );\n\thit.distance = hit.point.distanceTo( raycaster.ray.origin );\n\thit.object = object;\n\n\treturn hit;\n\n}\n","import { Ray, Matrix4, Mesh, Vector3, Sphere, BatchedMesh, REVISION } from 'three';\nimport { convertRaycastIntersect } from './GeometryRayIntersectUtilities.js';\nimport { MeshBVH } from '../core/MeshBVH.js';\n\nconst IS_REVISION_166 = parseInt( REVISION ) >= 166;\nconst ray = /* @__PURE__ */ new Ray();\nconst direction = /* @__PURE__ */ new Vector3();\nconst tmpInverseMatrix = /* @__PURE__ */ new Matrix4();\nconst origMeshRaycastFunc = Mesh.prototype.raycast;\nconst origBatchedRaycastFunc = BatchedMesh.prototype.raycast;\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _mesh = /* @__PURE__ */ new Mesh();\nconst _batchIntersects = [];\n\nexport function acceleratedRaycast( raycaster, intersects ) {\n\n\tif ( this.isBatchedMesh ) {\n\n\t\tacceleratedBatchedMeshRaycast.call( this, raycaster, intersects );\n\n\t} else {\n\n\t\tacceleratedMeshRaycast.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedBatchedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.boundsTrees ) {\n\n\t\t// TODO: remove use of geometry info, instance info when r170 is minimum version\n\t\tconst boundsTrees = this.boundsTrees;\n\t\tconst drawInfo = this._drawInfo || this._instanceInfo;\n\t\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\t\tconst matrixWorld = this.matrixWorld;\n\n\t\t_mesh.material = this.material;\n\t\t_mesh.geometry = this.geometry;\n\n\t\tconst oldBoundsTree = _mesh.geometry.boundsTree;\n\t\tconst oldDrawRange = _mesh.geometry.drawRange;\n\n\t\tif ( _mesh.geometry.boundingSphere === null ) {\n\n\t\t\t_mesh.geometry.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\t// TODO: provide new method to get instances count instead of 'drawInfo.length'\n\t\tfor ( let i = 0, l = drawInfo.length; i < l; i ++ ) {\n\n\t\t\tif ( ! this.getVisibleAt( i ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// TODO: use getGeometryIndex\n\t\t\tconst geometryId = drawInfo[ i ].geometryIndex;\n\n\t\t\t_mesh.geometry.boundsTree = boundsTrees[ geometryId ];\n\n\t\t\tthis.getMatrixAt( i, _mesh.matrixWorld ).premultiply( matrixWorld );\n\n\t\t\tif ( ! _mesh.geometry.boundsTree ) {\n\n\t\t\t\tthis.getBoundingBoxAt( geometryId, _mesh.geometry.boundingBox );\n\t\t\t\tthis.getBoundingSphereAt( geometryId, _mesh.geometry.boundingSphere );\n\n\t\t\t\tconst drawRange = drawRanges[ geometryId ];\n\t\t\t\t_mesh.geometry.setDrawRange( drawRange.start, drawRange.count );\n\n\t\t\t}\n\n\t\t\t_mesh.raycast( raycaster, _batchIntersects );\n\n\t\t\tfor ( let j = 0, l = _batchIntersects.length; j < l; j ++ ) {\n\n\t\t\t\tconst intersect = _batchIntersects[ j ];\n\t\t\t\tintersect.object = this;\n\t\t\t\tintersect.batchId = i;\n\t\t\t\tintersects.push( intersect );\n\n\t\t\t}\n\n\t\t\t_batchIntersects.length = 0;\n\n\t\t}\n\n\t\t_mesh.geometry.boundsTree = oldBoundsTree;\n\t\t_mesh.geometry.drawRange = oldDrawRange;\n\t\t_mesh.material = null;\n\t\t_mesh.geometry = null;\n\n\t} else {\n\n\t\torigBatchedRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nfunction acceleratedMeshRaycast( raycaster, intersects ) {\n\n\tif ( this.geometry.boundsTree ) {\n\n\t\tif ( this.material === undefined ) return;\n\n\t\ttmpInverseMatrix.copy( this.matrixWorld ).invert();\n\t\tray.copy( raycaster.ray ).applyMatrix4( tmpInverseMatrix );\n\n\t\t_worldScale.setFromMatrixScale( this.matrixWorld );\n\t\tdirection.copy( ray.direction ).multiply( _worldScale );\n\n\t\tconst scaleFactor = direction.length();\n\t\tconst near = raycaster.near / scaleFactor;\n\t\tconst far = raycaster.far / scaleFactor;\n\n\t\tconst bvh = this.geometry.boundsTree;\n\t\tif ( raycaster.firstHitOnly === true ) {\n\n\t\t\tconst hit = convertRaycastIntersect( bvh.raycastFirst( ray, this.material, near, far ), this, raycaster );\n\t\t\tif ( hit ) {\n\n\t\t\t\tintersects.push( hit );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconst hits = bvh.raycast( ray, this.material, near, far );\n\t\t\tfor ( let i = 0, l = hits.length; i < l; i ++ ) {\n\n\t\t\t\tconst hit = convertRaycastIntersect( hits[ i ], this, raycaster );\n\t\t\t\tif ( hit ) {\n\n\t\t\t\t\tintersects.push( hit );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} else {\n\n\t\torigMeshRaycastFunc.call( this, raycaster, intersects );\n\n\t}\n\n}\n\nexport function computeBoundsTree( options = {} ) {\n\n\tthis.boundsTree = new MeshBVH( this, options );\n\treturn this.boundsTree;\n\n}\n\nexport function disposeBoundsTree() {\n\n\tthis.boundsTree = null;\n\n}\n\nexport function computeBatchedBoundsTree( index = - 1, options = {} ) {\n\n\tif ( ! IS_REVISION_166 ) {\n\n\t\tthrow new Error( 'BatchedMesh: Three r166+ is required to compute bounds trees.' );\n\n\t}\n\n\tif ( options.indirect ) {\n\n\t\tconsole.warn( '\"Indirect\" is set to false because it is not supported for BatchedMesh.' );\n\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tindirect: false,\n\t\trange: null\n\t};\n\n\tconst drawRanges = this._drawRanges || this._geometryInfo;\n\tconst geometryCount = this._geometryCount;\n\tif ( ! this.boundsTrees ) {\n\n\t\tthis.boundsTrees = new Array( geometryCount ).fill( null );\n\n\t}\n\n\tconst boundsTrees = this.boundsTrees;\n\twhile ( boundsTrees.length < geometryCount ) {\n\n\t\tboundsTrees.push( null );\n\n\t}\n\n\tif ( index < 0 ) {\n\n\t\tfor ( let i = 0; i < geometryCount; i ++ ) {\n\n\t\t\toptions.range = drawRanges[ i ];\n\t\t\tboundsTrees[ i ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees;\n\n\t} else {\n\n\t\tif ( index < drawRanges.length ) {\n\n\t\t\toptions.range = drawRanges[ index ];\n\t\t\tboundsTrees[ index ] = new MeshBVH( this.geometry, options );\n\n\t\t}\n\n\t\treturn boundsTrees[ index ] || null;\n\n\t}\n\n}\n\nexport function disposeBatchedBoundsTree( index = - 1 ) {\n\n\tif ( index < 0 ) {\n\n\t\tthis.boundsTrees.fill( null );\n\n\t} else {\n\n\t\tif ( index < this.boundsTree.length ) {\n\n\t\t\tthis.boundsTrees[ index ] = null;\n\n\t\t}\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tIntType,\n\tUnsignedIntType,\n\tByteType,\n\tUnsignedByteType,\n\tShortType,\n\tUnsignedShortType,\n\n\tRedFormat,\n\tRGFormat,\n\tRGBAFormat,\n\n\tRedIntegerFormat,\n\tRGIntegerFormat,\n\tRGBAIntegerFormat,\n\n\tNearestFilter,\n} from 'three';\n\nfunction countToStringFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return 'R';\n\t\tcase 2: return 'RG';\n\t\tcase 3: return 'RGBA';\n\t\tcase 4: return 'RGBA';\n\n\t}\n\n\tthrow new Error();\n\n}\n\nfunction countToFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedFormat;\n\t\tcase 2: return RGFormat;\n\t\tcase 3: return RGBAFormat;\n\t\tcase 4: return RGBAFormat;\n\n\t}\n\n}\n\nfunction countToIntFormat( count ) {\n\n\tswitch ( count ) {\n\n\t\tcase 1: return RedIntegerFormat;\n\t\tcase 2: return RGIntegerFormat;\n\t\tcase 3: return RGBAIntegerFormat;\n\t\tcase 4: return RGBAIntegerFormat;\n\n\t}\n\n}\n\nexport class VertexAttributeTexture extends DataTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis.minFilter = NearestFilter;\n\t\tthis.magFilter = NearestFilter;\n\t\tthis.generateMipmaps = false;\n\t\tthis.overrideItemSize = null;\n\t\tthis._forcedType = null;\n\n\t}\n\n\tupdateFrom( attr ) {\n\n\t\tconst overrideItemSize = this.overrideItemSize;\n\t\tconst originalItemSize = attr.itemSize;\n\t\tconst originalCount = attr.count;\n\t\tif ( overrideItemSize !== null ) {\n\n\t\t\tif ( ( originalItemSize * originalCount ) % overrideItemSize !== 0.0 ) {\n\n\t\t\t\tthrow new Error( 'VertexAttributeTexture: overrideItemSize must divide evenly into buffer length.' );\n\n\t\t\t}\n\n\t\t\tattr.itemSize = overrideItemSize;\n\t\t\tattr.count = originalCount * originalItemSize / overrideItemSize;\n\n\t\t}\n\n\t\tconst itemSize = attr.itemSize;\n\t\tconst count = attr.count;\n\t\tconst normalized = attr.normalized;\n\t\tconst originalBufferCons = attr.array.constructor;\n\t\tconst byteCount = originalBufferCons.BYTES_PER_ELEMENT;\n\t\tlet targetType = this._forcedType;\n\t\tlet finalStride = itemSize;\n\n\t\t// derive the type of texture this should be in the shader\n\t\tif ( targetType === null ) {\n\n\t\t\tswitch ( originalBufferCons ) {\n\n\t\t\t\tcase Float32Array:\n\t\t\t\t\ttargetType = FloatType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Uint8Array:\n\t\t\t\tcase Uint16Array:\n\t\t\t\tcase Uint32Array:\n\t\t\t\t\ttargetType = UnsignedIntType;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Int8Array:\n\t\t\t\tcase Int16Array:\n\t\t\t\tcase Int32Array:\n\t\t\t\t\ttargetType = IntType;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get the target format to store the texture as\n\t\tlet type, format, normalizeValue, targetBufferCons;\n\t\tlet internalFormat = countToStringFormat( itemSize );\n\t\tswitch ( targetType ) {\n\n\t\t\tcase FloatType:\n\t\t\t\tnormalizeValue = 1.0;\n\t\t\t\tformat = countToFormat( itemSize );\n\n\t\t\t\tif ( normalized && byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = originalBufferCons;\n\t\t\t\t\tinternalFormat += '8';\n\n\t\t\t\t\tif ( originalBufferCons === Uint8Array ) {\n\n\t\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttype = ByteType;\n\t\t\t\t\t\tinternalFormat += '_SNORM';\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Float32Array;\n\t\t\t\t\tinternalFormat += '32F';\n\t\t\t\t\ttype = FloatType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase IntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'I';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Int8Array;\n\t\t\t\t\ttype = ByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Int16Array;\n\t\t\t\t\ttype = ShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Int32Array;\n\t\t\t\t\ttype = IntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase UnsignedIntType:\n\t\t\t\tinternalFormat += byteCount * 8 + 'UI';\n\t\t\t\tnormalizeValue = normalized ? Math.pow( 2, originalBufferCons.BYTES_PER_ELEMENT * 8 - 1 ) : 1.0;\n\t\t\t\tformat = countToIntFormat( itemSize );\n\n\t\t\t\tif ( byteCount === 1 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint8Array;\n\t\t\t\t\ttype = UnsignedByteType;\n\n\t\t\t\t} else if ( byteCount === 2 ) {\n\n\t\t\t\t\ttargetBufferCons = Uint16Array;\n\t\t\t\t\ttype = UnsignedShortType;\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttargetBufferCons = Uint32Array;\n\t\t\t\t\ttype = UnsignedIntType;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t// there will be a mismatch between format length and final length because\n\t\t// RGBFormat and RGBIntegerFormat was removed\n\t\tif ( finalStride === 3 && ( format === RGBAFormat || format === RGBAIntegerFormat ) ) {\n\n\t\t\tfinalStride = 4;\n\n\t\t}\n\n\t\t// copy the data over to the new texture array\n\t\tconst dimension = Math.ceil( Math.sqrt( count ) ) || 1;\n\t\tconst length = finalStride * dimension * dimension;\n\t\tconst dataArray = new targetBufferCons( length );\n\n\t\t// temporarily set the normalized state to false since we have custom normalization logic\n\t\tconst originalNormalized = attr.normalized;\n\t\tattr.normalized = false;\n\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\tconst ii = finalStride * i;\n\t\t\tdataArray[ ii ] = attr.getX( i ) / normalizeValue;\n\n\t\t\tif ( itemSize >= 2 ) {\n\n\t\t\t\tdataArray[ ii + 1 ] = attr.getY( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 3 ) {\n\n\t\t\t\tdataArray[ ii + 2 ] = attr.getZ( i ) / normalizeValue;\n\n\t\t\t\tif ( finalStride === 4 ) {\n\n\t\t\t\t\tdataArray[ ii + 3 ] = 1.0;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( itemSize >= 4 ) {\n\n\t\t\t\tdataArray[ ii + 3 ] = attr.getW( i ) / normalizeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\tattr.normalized = originalNormalized;\n\n\t\tthis.internalFormat = internalFormat;\n\t\tthis.format = format;\n\t\tthis.type = type;\n\t\tthis.image.width = dimension;\n\t\tthis.image.height = dimension;\n\t\tthis.image.data = dataArray;\n\t\tthis.needsUpdate = true;\n\t\tthis.dispose();\n\n\t\tattr.itemSize = originalItemSize;\n\t\tattr.count = originalCount;\n\n\t}\n\n}\n\nexport class UIntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = UnsignedIntType;\n\n\t}\n\n}\n\nexport class IntVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = IntType;\n\n\t}\n\n\n}\n\nexport class FloatVertexAttributeTexture extends VertexAttributeTexture {\n\n\tconstructor() {\n\n\t\tsuper();\n\t\tthis._forcedType = FloatType;\n\n\t}\n\n}\n","import {\n\tDataTexture,\n\tFloatType,\n\tUnsignedIntType,\n\tRGBAFormat,\n\tRGIntegerFormat,\n\tNearestFilter,\n\tBufferAttribute,\n} from 'three';\nimport {\n\tFloatVertexAttributeTexture,\n\tUIntVertexAttributeTexture,\n} from './VertexAttributeTexture.js';\nimport { BYTES_PER_NODE } from '../core/Constants.js';\nimport {\n\tBOUNDING_DATA_INDEX,\n\tCOUNT,\n\tIS_LEAF,\n\tRIGHT_NODE,\n\tOFFSET,\n\tSPLIT_AXIS,\n} from '../core/utils/nodeBufferUtils.js';\nimport { getIndexArray, getVertexCount } from '../core/build/geometryUtils.js';\n\nexport class MeshBVHUniformStruct {\n\n\tconstructor() {\n\n\t\tthis.index = new UIntVertexAttributeTexture();\n\t\tthis.position = new FloatVertexAttributeTexture();\n\t\tthis.bvhBounds = new DataTexture();\n\t\tthis.bvhContents = new DataTexture();\n\t\tthis._cachedIndexAttr = null;\n\n\t\tthis.index.overrideItemSize = 3;\n\n\t}\n\n\tupdateFrom( bvh ) {\n\n\t\tconst { geometry } = bvh;\n\t\tbvhToTextures( bvh, this.bvhBounds, this.bvhContents );\n\n\t\tthis.position.updateFrom( geometry.attributes.position );\n\n\t\t// dereference a new index attribute if we're using indirect storage\n\t\tif ( bvh.indirect ) {\n\n\t\t\tconst indirectBuffer = bvh._indirectBuffer;\n\t\t\tif (\n\t\t\t\tthis._cachedIndexAttr === null ||\n\t\t\t\tthis._cachedIndexAttr.count !== indirectBuffer.length\n\t\t\t) {\n\n\t\t\t\tif ( geometry.index ) {\n\n\t\t\t\t\tthis._cachedIndexAttr = geometry.index.clone();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst array = getIndexArray( getVertexCount( geometry ) );\n\t\t\t\t\tthis._cachedIndexAttr = new BufferAttribute( array, 1, false );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tdereferenceIndex( geometry, indirectBuffer, this._cachedIndexAttr );\n\t\t\tthis.index.updateFrom( this._cachedIndexAttr );\n\n\t\t} else {\n\n\t\t\tthis.index.updateFrom( geometry.index );\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tconst { index, position, bvhBounds, bvhContents } = this;\n\n\t\tif ( index ) index.dispose();\n\t\tif ( position ) position.dispose();\n\t\tif ( bvhBounds ) bvhBounds.dispose();\n\t\tif ( bvhContents ) bvhContents.dispose();\n\n\t}\n\n}\n\nfunction dereferenceIndex( geometry, indirectBuffer, target ) {\n\n\tconst unpacked = target.array;\n\tconst indexArray = geometry.index ? geometry.index.array : null;\n\tfor ( let i = 0, l = indirectBuffer.length; i < l; i ++ ) {\n\n\t\tconst i3 = 3 * i;\n\t\tconst v3 = 3 * indirectBuffer[ i ];\n\t\tfor ( let c = 0; c < 3; c ++ ) {\n\n\t\t\tunpacked[ i3 + c ] = indexArray ? indexArray[ v3 + c ] : v3 + c;\n\n\t\t}\n\n\t}\n\n}\n\nfunction bvhToTextures( bvh, boundsTexture, contentsTexture ) {\n\n\tconst roots = bvh._roots;\n\n\tif ( roots.length !== 1 ) {\n\n\t\tthrow new Error( 'MeshBVHUniformStruct: Multi-root BVHs not supported.' );\n\n\t}\n\n\tconst root = roots[ 0 ];\n\tconst uint16Array = new Uint16Array( root );\n\tconst uint32Array = new Uint32Array( root );\n\tconst float32Array = new Float32Array( root );\n\n\t// Both bounds need two elements per node so compute the height so it's twice as long as\n\t// the width so we can expand the row by two and still have a square texture\n\tconst nodeCount = root.byteLength / BYTES_PER_NODE;\n\tconst boundsDimension = 2 * Math.ceil( Math.sqrt( nodeCount / 2 ) );\n\tconst boundsArray = new Float32Array( 4 * boundsDimension * boundsDimension );\n\n\tconst contentsDimension = Math.ceil( Math.sqrt( nodeCount ) );\n\tconst contentsArray = new Uint32Array( 2 * contentsDimension * contentsDimension );\n\n\tfor ( let i = 0; i < nodeCount; i ++ ) {\n\n\t\tconst nodeIndex32 = i * BYTES_PER_NODE / 4;\n\t\tconst nodeIndex16 = nodeIndex32 * 2;\n\t\tconst boundsIndex = BOUNDING_DATA_INDEX( nodeIndex32 );\n\t\tfor ( let b = 0; b < 3; b ++ ) {\n\n\t\t\tboundsArray[ 8 * i + 0 + b ] = float32Array[ boundsIndex + 0 + b ];\n\t\t\tboundsArray[ 8 * i + 4 + b ] = float32Array[ boundsIndex + 3 + b ];\n\n\t\t}\n\n\t\tif ( IS_LEAF( nodeIndex16, uint16Array ) ) {\n\n\t\t\tconst count = COUNT( nodeIndex16, uint16Array );\n\t\t\tconst offset = OFFSET( nodeIndex32, uint32Array );\n\n\t\t\tconst mergedLeafCount = 0xffff0000 | count;\n\t\t\tcontentsArray[ i * 2 + 0 ] = mergedLeafCount;\n\t\t\tcontentsArray[ i * 2 + 1 ] = offset;\n\n\t\t} else {\n\n\t\t\tconst rightIndex = 4 * RIGHT_NODE( nodeIndex32, uint32Array ) / BYTES_PER_NODE;\n\t\t\tconst splitAxis = SPLIT_AXIS( nodeIndex32, uint32Array );\n\n\t\t\tcontentsArray[ i * 2 + 0 ] = splitAxis;\n\t\t\tcontentsArray[ i * 2 + 1 ] = rightIndex;\n\n\t\t}\n\n\t}\n\n\tboundsTexture.image.data = boundsArray;\n\tboundsTexture.image.width = boundsDimension;\n\tboundsTexture.image.height = boundsDimension;\n\tboundsTexture.format = RGBAFormat;\n\tboundsTexture.type = FloatType;\n\tboundsTexture.internalFormat = 'RGBA32F';\n\tboundsTexture.minFilter = NearestFilter;\n\tboundsTexture.magFilter = NearestFilter;\n\tboundsTexture.generateMipmaps = false;\n\tboundsTexture.needsUpdate = true;\n\tboundsTexture.dispose();\n\n\tcontentsTexture.image.data = contentsArray;\n\tcontentsTexture.image.width = contentsDimension;\n\tcontentsTexture.image.height = contentsDimension;\n\tcontentsTexture.format = RGIntegerFormat;\n\tcontentsTexture.type = UnsignedIntType;\n\tcontentsTexture.internalFormat = 'RG32UI';\n\tcontentsTexture.minFilter = NearestFilter;\n\tcontentsTexture.magFilter = NearestFilter;\n\tcontentsTexture.generateMipmaps = false;\n\tcontentsTexture.needsUpdate = true;\n\tcontentsTexture.dispose();\n\n}\n","import { BufferAttribute, BufferGeometry, Vector3, Vector4, Matrix4, Matrix3 } from 'three';\n\nconst _positionVector = /*@__PURE__*/ new Vector3();\nconst _normalVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector = /*@__PURE__*/ new Vector3();\nconst _tangentVector4 = /*@__PURE__*/ new Vector4();\n\nconst _morphVector = /*@__PURE__*/ new Vector3();\nconst _temp = /*@__PURE__*/ new Vector3();\n\nconst _skinIndex = /*@__PURE__*/ new Vector4();\nconst _skinWeight = /*@__PURE__*/ new Vector4();\nconst _matrix = /*@__PURE__*/ new Matrix4();\nconst _boneMatrix = /*@__PURE__*/ new Matrix4();\n\n// Confirms that the two provided attributes are compatible\nfunction validateAttributes( attr1, attr2 ) {\n\n\tif ( ! attr1 && ! attr2 ) {\n\n\t\treturn;\n\n\t}\n\n\tconst sameCount = attr1.count === attr2.count;\n\tconst sameNormalized = attr1.normalized === attr2.normalized;\n\tconst sameType = attr1.array.constructor === attr2.array.constructor;\n\tconst sameItemSize = attr1.itemSize === attr2.itemSize;\n\n\tif ( ! sameCount || ! sameNormalized || ! sameType || ! sameItemSize ) {\n\n\t\tthrow new Error();\n\n\t}\n\n}\n\n// Clones the given attribute with a new compatible buffer attribute but no data\nfunction createAttributeClone( attr, countOverride = null ) {\n\n\tconst cons = attr.array.constructor;\n\tconst normalized = attr.normalized;\n\tconst itemSize = attr.itemSize;\n\tconst count = countOverride === null ? attr.count : countOverride;\n\n\treturn new BufferAttribute( new cons( itemSize * count ), itemSize, normalized );\n\n}\n\n// target offset is the number of elements in the target buffer stride to skip before copying the\n// attributes contents in to.\nfunction copyAttributeContents( attr, target, targetOffset = 0 ) {\n\n\tif ( attr.isInterleavedBufferAttribute ) {\n\n\t\tconst itemSize = attr.itemSize;\n\t\tfor ( let i = 0, l = attr.count; i < l; i ++ ) {\n\n\t\t\tconst io = i + targetOffset;\n\t\t\ttarget.setX( io, attr.getX( i ) );\n\t\t\tif ( itemSize >= 2 ) target.setY( io, attr.getY( i ) );\n\t\t\tif ( itemSize >= 3 ) target.setZ( io, attr.getZ( i ) );\n\t\t\tif ( itemSize >= 4 ) target.setW( io, attr.getW( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst array = target.array;\n\t\tconst cons = array.constructor;\n\t\tconst byteOffset = array.BYTES_PER_ELEMENT * attr.itemSize * targetOffset;\n\t\tconst temp = new cons( array.buffer, byteOffset, attr.array.length );\n\t\ttemp.set( attr.array );\n\n\t}\n\n}\n\n// Adds the \"matrix\" multiplied by \"scale\" to \"target\"\nfunction addScaledMatrix( target, matrix, scale ) {\n\n\tconst targetArray = target.elements;\n\tconst matrixArray = matrix.elements;\n\tfor ( let i = 0, l = matrixArray.length; i < l; i ++ ) {\n\n\t\ttargetArray[ i ] += matrixArray[ i ] * scale;\n\n\t}\n\n}\n\n// A version of \"SkinnedMesh.boneTransform\" for normals\nfunction boneNormalTransform( mesh, index, target ) {\n\n\tconst skeleton = mesh.skeleton;\n\tconst geometry = mesh.geometry;\n\tconst bones = skeleton.bones;\n\tconst boneInverses = skeleton.boneInverses;\n\n\t_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );\n\t_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );\n\n\t_matrix.elements.fill( 0 );\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst weight = _skinWeight.getComponent( i );\n\n\t\tif ( weight !== 0 ) {\n\n\t\t\tconst boneIndex = _skinIndex.getComponent( i );\n\t\t\t_boneMatrix.multiplyMatrices( bones[ boneIndex ].matrixWorld, boneInverses[ boneIndex ] );\n\n\t\t\taddScaledMatrix( _matrix, _boneMatrix, weight );\n\n\t\t}\n\n\t}\n\n\t_matrix.multiply( mesh.bindMatrix ).premultiply( mesh.bindMatrixInverse );\n\ttarget.transformDirection( _matrix );\n\n\treturn target;\n\n}\n\n// Applies the morph target data to the target vector\nfunction applyMorphTarget( morphData, morphInfluences, morphTargetsRelative, i, target ) {\n\n\t_morphVector.set( 0, 0, 0 );\n\tfor ( let j = 0, jl = morphData.length; j < jl; j ++ ) {\n\n\t\tconst influence = morphInfluences[ j ];\n\t\tconst morphAttribute = morphData[ j ];\n\n\t\tif ( influence === 0 ) continue;\n\n\t\t_temp.fromBufferAttribute( morphAttribute, i );\n\n\t\tif ( morphTargetsRelative ) {\n\n\t\t\t_morphVector.addScaledVector( _temp, influence );\n\n\t\t} else {\n\n\t\t\t_morphVector.addScaledVector( _temp.sub( target ), influence );\n\n\t\t}\n\n\t}\n\n\ttarget.add( _morphVector );\n\n}\n\n// Modified version of BufferGeometryUtils.mergeBufferGeometries that ignores morph targets and updates a attributes in place\nfunction mergeBufferGeometries( geometries, options = { useGroups: false, updateIndex: false, skipAttributes: [] }, targetGeometry = new BufferGeometry() ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\tconst { useGroups = false, updateIndex = false, skipAttributes = [] } = options;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst attributes = {};\n\n\tlet offset = 0;\n\n\ttargetGeometry.clearGroups();\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) {\n\n\t\t\t\tattributes[ name ] = [];\n\n\t\t\t}\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tthrow new Error( 'StaticGeometryGenerator: Make sure all geometries have the same number of attributes.' );\n\n\t\t}\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tthrow new Error( 'StaticGeometryGenerator: The geometry must have either an index or a position attribute' );\n\n\t\t\t}\n\n\t\t\ttargetGeometry.addGroup( offset, count, i );\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\tif ( isIndexed ) {\n\n\t\tlet forceUpdateIndex = false;\n\t\tif ( ! targetGeometry.index ) {\n\n\t\t\tlet indexCount = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tindexCount += geometries[ i ].index.count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setIndex( new BufferAttribute( new Uint32Array( indexCount ), 1, false ) );\n\t\t\tforceUpdateIndex = true;\n\n\t\t}\n\n\t\tif ( updateIndex || forceUpdateIndex ) {\n\n\t\t\tconst targetIndex = targetGeometry.index;\n\t\t\tlet targetOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\t\tconst geometry = geometries[ i ];\n\t\t\t\tconst index = geometry.index;\n\t\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\t\t\ttargetIndex.setX( targetOffset, index.getX( j ) + indexOffset );\n\t\t\t\t\t\ttargetOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tindexOffset += geometry.attributes.position.count;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// merge attributes\n\tfor ( const name in attributes ) {\n\n\t\tconst attrList = attributes[ name ];\n\t\tif ( ! ( name in targetGeometry.attributes ) ) {\n\n\t\t\tlet count = 0;\n\t\t\tfor ( const key in attrList ) {\n\n\t\t\t\tcount += attrList[ key ].count;\n\n\t\t\t}\n\n\t\t\ttargetGeometry.setAttribute( name, createAttributeClone( attributes[ name ][ 0 ], count ) );\n\n\t\t}\n\n\t\tconst targetAttribute = targetGeometry.attributes[ name ];\n\t\tlet offset = 0;\n\t\tfor ( let i = 0, l = attrList.length; i < l; i ++ ) {\n\n\t\t\tconst attr = attrList[ i ];\n\t\t\tif ( skipAttributes[ i ] !== true ) {\n\n\t\t\t\tcopyAttributeContents( attr, targetAttribute, offset );\n\n\t\t\t}\n\n\t\t\toffset += attr.count;\n\n\t\t}\n\n\t}\n\n\treturn targetGeometry;\n\n}\n\nfunction checkTypedArrayEquality( a, b ) {\n\n\tif ( a === null || b === null ) {\n\n\t\treturn a === b;\n\n\t}\n\n\tif ( a.length !== b.length ) {\n\n\t\treturn false;\n\n\t}\n\n\tfor ( let i = 0, l = a.length; i < l; i ++ ) {\n\n\t\tif ( a[ i ] !== b[ i ] ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nfunction invertGeometry( geometry ) {\n\n\tconst { index, attributes } = geometry;\n\tif ( index ) {\n\n\t\tfor ( let i = 0, l = index.count; i < l; i += 3 ) {\n\n\t\t\tconst v0 = index.getX( i );\n\t\t\tconst v2 = index.getX( i + 2 );\n\t\t\tindex.setX( i, v2 );\n\t\t\tindex.setX( i + 2, v0 );\n\n\t\t}\n\n\t} else {\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attr = attributes[ key ];\n\t\t\tconst itemSize = attr.itemSize;\n\t\t\tfor ( let i = 0, l = attr.count; i < l; i += 3 ) {\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tconst v0 = attr.getComponent( i, j );\n\t\t\t\t\tconst v2 = attr.getComponent( i + 2, j );\n\t\t\t\t\tattr.setComponent( i, j, v2 );\n\t\t\t\t\tattr.setComponent( i + 2, j, v0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn geometry;\n\n\n}\n\n// Checks whether the geometry changed between this and last evaluation\nclass GeometryDiff {\n\n\tconstructor( mesh ) {\n\n\t\tthis.matrixWorld = new Matrix4();\n\t\tthis.geometryHash = null;\n\t\tthis.boneMatrices = null;\n\t\tthis.primitiveCount = - 1;\n\t\tthis.mesh = mesh;\n\n\t\tthis.update();\n\n\t}\n\n\tupdate() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst skeleton = mesh.skeleton;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tthis.matrixWorld.copy( mesh.matrixWorld );\n\t\tthis.geometryHash = geometry.attributes.position.version;\n\t\tthis.primitiveCount = primitiveCount;\n\n\t\tif ( skeleton ) {\n\n\t\t\t// ensure the bone matrix array is updated to the appropriate length\n\t\t\tif ( ! skeleton.boneTexture ) {\n\n\t\t\t\tskeleton.computeBoneTexture();\n\n\t\t\t}\n\n\t\t\tskeleton.update();\n\n\t\t\t// copy data if possible otherwise clone it\n\t\t\tconst boneMatrices = skeleton.boneMatrices;\n\t\t\tif ( ! this.boneMatrices || this.boneMatrices.length !== boneMatrices.length ) {\n\n\t\t\t\tthis.boneMatrices = boneMatrices.slice();\n\n\t\t\t} else {\n\n\t\t\t\tthis.boneMatrices.set( boneMatrices );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boneMatrices = null;\n\n\t\t}\n\n\t}\n\n\tdidChange() {\n\n\t\tconst mesh = this.mesh;\n\t\tconst geometry = mesh.geometry;\n\t\tconst primitiveCount = ( geometry.index ? geometry.index.count : geometry.attributes.position.count ) / 3;\n\t\tconst identical =\n\t\t\tthis.matrixWorld.equals( mesh.matrixWorld ) &&\n\t\t\tthis.geometryHash === geometry.attributes.position.version &&\n\t\t\tcheckTypedArrayEquality( mesh.skeleton && mesh.skeleton.boneMatrices || null, this.boneMatrices ) &&\n\t\t\tthis.primitiveCount === primitiveCount;\n\n\t\treturn ! identical;\n\n\t}\n\n}\n\nexport class StaticGeometryGenerator {\n\n\tconstructor( meshes ) {\n\n\t\tif ( ! Array.isArray( meshes ) ) {\n\n\t\t\tmeshes = [ meshes ];\n\n\t\t}\n\n\t\tconst finalMeshes = [];\n\t\tmeshes.forEach( object => {\n\n\t\t\tobject.traverseVisible( c => {\n\n\t\t\t\tif ( c.isMesh ) {\n\n\t\t\t\t\tfinalMeshes.push( c );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t} );\n\n\t\tthis.meshes = finalMeshes;\n\t\tthis.useGroups = true;\n\t\tthis.applyWorldTransforms = true;\n\t\tthis.attributes = [ 'position', 'normal', 'color', 'tangent', 'uv', 'uv2' ];\n\t\tthis._intermediateGeometry = new Array( finalMeshes.length ).fill().map( () => new BufferGeometry() );\n\t\tthis._diffMap = new WeakMap();\n\n\t}\n\n\tgetMaterials() {\n\n\t\tconst materials = [];\n\t\tthis.meshes.forEach( mesh => {\n\n\t\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\t\tmaterials.push( ...mesh.material );\n\n\t\t\t} else {\n\n\t\t\t\tmaterials.push( mesh.material );\n\n\t\t\t}\n\n\t\t} );\n\t\treturn materials;\n\n\t}\n\n\tgenerate( targetGeometry = new BufferGeometry() ) {\n\n\t\t// track which attributes have been updated and which to skip to avoid unnecessary attribute copies\n\t\tlet skipAttributes = [];\n\t\tconst { meshes, useGroups, _intermediateGeometry, _diffMap } = this;\n\t\tfor ( let i = 0, l = meshes.length; i < l; i ++ ) {\n\n\t\t\tconst mesh = meshes[ i ];\n\t\t\tconst geom = _intermediateGeometry[ i ];\n\t\t\tconst diff = _diffMap.get( mesh );\n\t\t\tif ( ! diff || diff.didChange( mesh ) ) {\n\n\t\t\t\tthis._convertToStaticGeometry( mesh, geom );\n\t\t\t\tskipAttributes.push( false );\n\n\t\t\t\tif ( ! diff ) {\n\n\t\t\t\t\t_diffMap.set( mesh, new GeometryDiff( mesh ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdiff.update();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tskipAttributes.push( true );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( _intermediateGeometry.length === 0 ) {\n\n\t\t\t// if there are no geometries then just create a fake empty geometry to provide\n\t\t\ttargetGeometry.setIndex( null );\n\n\t\t\t// remove all geometry\n\t\t\tconst attrs = targetGeometry.attributes;\n\t\t\tfor ( const key in attrs ) {\n\n\t\t\t\ttargetGeometry.deleteAttribute( key );\n\n\t\t\t}\n\n\t\t\t// create dummy attributes\n\t\t\tfor ( const key in this.attributes ) {\n\n\t\t\t\ttargetGeometry.setAttribute( this.attributes[ key ], new BufferAttribute( new Float32Array( 0 ), 4, false ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmergeBufferGeometries( _intermediateGeometry, { useGroups, skipAttributes }, targetGeometry );\n\n\t\t}\n\n\t\tfor ( const key in targetGeometry.attributes ) {\n\n\t\t\ttargetGeometry.attributes[ key ].needsUpdate = true;\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n\t_convertToStaticGeometry( mesh, targetGeometry = new BufferGeometry() ) {\n\n\t\tconst geometry = mesh.geometry;\n\t\tconst applyWorldTransforms = this.applyWorldTransforms;\n\t\tconst includeNormal = this.attributes.includes( 'normal' );\n\t\tconst includeTangent = this.attributes.includes( 'tangent' );\n\t\tconst attributes = geometry.attributes;\n\t\tconst targetAttributes = targetGeometry.attributes;\n\n\t\t// initialize the attributes if they don't exist\n\t\tif ( ! targetGeometry.index && geometry.index ) {\n\n\t\t\ttargetGeometry.index = geometry.index.clone();\n\n\t\t}\n\n\t\tif ( ! targetAttributes.position ) {\n\n\t\t\ttargetGeometry.setAttribute( 'position', createAttributeClone( attributes.position ) );\n\n\t\t}\n\n\t\tif ( includeNormal && ! targetAttributes.normal && attributes.normal ) {\n\n\t\t\ttargetGeometry.setAttribute( 'normal', createAttributeClone( attributes.normal ) );\n\n\t\t}\n\n\t\tif ( includeTangent && ! targetAttributes.tangent && attributes.tangent ) {\n\n\t\t\ttargetGeometry.setAttribute( 'tangent', createAttributeClone( attributes.tangent ) );\n\n\t\t}\n\n\t\t// ensure the attributes are consistent\n\t\tvalidateAttributes( geometry.index, targetGeometry.index );\n\t\tvalidateAttributes( attributes.position, targetAttributes.position );\n\n\t\tif ( includeNormal ) {\n\n\t\t\tvalidateAttributes( attributes.normal, targetAttributes.normal );\n\n\t\t}\n\n\t\tif ( includeTangent ) {\n\n\t\t\tvalidateAttributes( attributes.tangent, targetAttributes.tangent );\n\n\t\t}\n\n\t\t// generate transformed vertex attribute data\n\t\tconst position = attributes.position;\n\t\tconst normal = includeNormal ? attributes.normal : null;\n\t\tconst tangent = includeTangent ? attributes.tangent : null;\n\t\tconst morphPosition = geometry.morphAttributes.position;\n\t\tconst morphNormal = geometry.morphAttributes.normal;\n\t\tconst morphTangent = geometry.morphAttributes.tangent;\n\t\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\t\tconst morphInfluences = mesh.morphTargetInfluences;\n\t\tconst normalMatrix = new Matrix3();\n\t\tnormalMatrix.getNormalMatrix( mesh.matrixWorld );\n\n\t\t// copy the index\n\t\tif ( geometry.index ) {\n\n\t\t\ttargetGeometry.index.array.set( geometry.index.array );\n\n\t\t}\n\n\t\t// copy and apply other attributes\n\t\tfor ( let i = 0, l = attributes.position.count; i < l; i ++ ) {\n\n\t\t\t_positionVector.fromBufferAttribute( position, i );\n\t\t\tif ( normal ) {\n\n\t\t\t\t_normalVector.fromBufferAttribute( normal, i );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\t_tangentVector4.fromBufferAttribute( tangent, i );\n\t\t\t\t_tangentVector.fromBufferAttribute( tangent, i );\n\n\t\t\t}\n\n\t\t\t// apply morph target transform\n\t\t\tif ( morphInfluences ) {\n\n\t\t\t\tif ( morphPosition ) {\n\n\t\t\t\t\tapplyMorphTarget( morphPosition, morphInfluences, morphTargetsRelative, i, _positionVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphNormal ) {\n\n\t\t\t\t\tapplyMorphTarget( morphNormal, morphInfluences, morphTargetsRelative, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( morphTangent ) {\n\n\t\t\t\t\tapplyMorphTarget( morphTangent, morphInfluences, morphTargetsRelative, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// apply bone transform\n\t\t\tif ( mesh.isSkinnedMesh ) {\n\n\t\t\t\tmesh.applyBoneTransform( i, _positionVector );\n\t\t\t\tif ( normal ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _normalVector );\n\n\t\t\t\t}\n\n\t\t\t\tif ( tangent ) {\n\n\t\t\t\t\tboneNormalTransform( mesh, i, _tangentVector );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the vectors of the attributes\n\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t_positionVector.applyMatrix4( mesh.matrixWorld );\n\n\t\t\t}\n\n\t\t\ttargetAttributes.position.setXYZ( i, _positionVector.x, _positionVector.y, _positionVector.z );\n\n\t\t\tif ( normal ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_normalVector.applyNormalMatrix( normalMatrix );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.normal.setXYZ( i, _normalVector.x, _normalVector.y, _normalVector.z );\n\n\t\t\t}\n\n\t\t\tif ( tangent ) {\n\n\t\t\t\tif ( applyWorldTransforms ) {\n\n\t\t\t\t\t_tangentVector.transformDirection( mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t\ttargetAttributes.tangent.setXYZW( i, _tangentVector.x, _tangentVector.y, _tangentVector.z, _tangentVector4.w );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// copy other attributes over\n\t\tfor ( const i in this.attributes ) {\n\n\t\t\tconst key = this.attributes[ i ];\n\t\t\tif ( key === 'position' || key === 'tangent' || key === 'normal' || ! ( key in attributes ) ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( ! targetAttributes[ key ] ) {\n\n\t\t\t\ttargetGeometry.setAttribute( key, createAttributeClone( attributes[ key ] ) );\n\n\t\t\t}\n\n\t\t\tvalidateAttributes( attributes[ key ], targetAttributes[ key ] );\n\t\t\tcopyAttributeContents( attributes[ key ], targetAttributes[ key ] );\n\n\t\t}\n\n\t\tif ( mesh.matrixWorld.determinant() < 0 ) {\n\n\t\t\tinvertGeometry( targetGeometry );\n\n\t\t}\n\n\t\treturn targetGeometry;\n\n\t}\n\n}\n","export const common_functions = /* glsl */`\n\n// A stack of uint32 indices can can store the indices for\n// a perfectly balanced tree with a depth up to 31. Lower stack\n// depth gets higher performance.\n//\n// However not all trees are balanced. Best value to set this to\n// is the trees max depth.\n#ifndef BVH_STACK_DEPTH\n#define BVH_STACK_DEPTH 60\n#endif\n\n#ifndef INFINITY\n#define INFINITY 1e20\n#endif\n\n// Utilities\nuvec4 uTexelFetch1D( usampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nivec4 iTexelFetch1D( isampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 texelFetch1D( sampler2D tex, uint index ) {\n\n\tuint width = uint( textureSize( tex, 0 ).x );\n\tuvec2 uv;\n\tuv.x = index % width;\n\tuv.y = index / width;\n\n\treturn texelFetch( tex, ivec2( uv ), 0 );\n\n}\n\nvec4 textureSampleBarycoord( sampler2D tex, vec3 barycoord, uvec3 faceIndices ) {\n\n\treturn\n\t\tbarycoord.x * texelFetch1D( tex, faceIndices.x ) +\n\t\tbarycoord.y * texelFetch1D( tex, faceIndices.y ) +\n\t\tbarycoord.z * texelFetch1D( tex, faceIndices.z );\n\n}\n\nvoid ndcToCameraRay(\n\tvec2 coord, mat4 cameraWorld, mat4 invProjectionMatrix,\n\tout vec3 rayOrigin, out vec3 rayDirection\n) {\n\n\t// get camera look direction and near plane for camera clipping\n\tvec4 lookDirection = cameraWorld * vec4( 0.0, 0.0, - 1.0, 0.0 );\n\tvec4 nearVector = invProjectionMatrix * vec4( 0.0, 0.0, - 1.0, 1.0 );\n\tfloat near = abs( nearVector.z / nearVector.w );\n\n\t// get the camera direction and position from camera matrices\n\tvec4 origin = cameraWorld * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec4 direction = invProjectionMatrix * vec4( coord, 0.5, 1.0 );\n\tdirection /= direction.w;\n\tdirection = cameraWorld * direction - origin;\n\n\t// slide the origin along the ray until it sits at the near clip plane position\n\torigin.xyz += direction.xyz * near / dot( direction, lookDirection );\n\n\trayOrigin = origin.xyz;\n\trayDirection = direction.xyz;\n\n}\n`;\n","// Distance to Point\nexport const bvh_distance_functions = /* glsl */`\n\nfloat dot2( vec3 v ) {\n\n\treturn dot( v, v );\n\n}\n\n// https://www.shadertoy.com/view/ttfGWl\nvec3 closestPointToTriangle( vec3 p, vec3 v0, vec3 v1, vec3 v2, out vec3 barycoord ) {\n\n    vec3 v10 = v1 - v0;\n    vec3 v21 = v2 - v1;\n    vec3 v02 = v0 - v2;\n\n\tvec3 p0 = p - v0;\n\tvec3 p1 = p - v1;\n\tvec3 p2 = p - v2;\n\n    vec3 nor = cross( v10, v02 );\n\n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0 / dot2( nor );\n    float u = d * dot( q, v02 );\n    float v = d * dot( q, v10 );\n    float w = 1.0 - u - v;\n\n\tif( u < 0.0 ) {\n\n\t\tw = clamp( dot( p2, v02 ) / dot2( v02 ), 0.0, 1.0 );\n\t\tu = 0.0;\n\t\tv = 1.0 - w;\n\n\t} else if( v < 0.0 ) {\n\n\t\tu = clamp( dot( p0, v10 ) / dot2( v10 ), 0.0, 1.0 );\n\t\tv = 0.0;\n\t\tw = 1.0 - u;\n\n\t} else if( w < 0.0 ) {\n\n\t\tv = clamp( dot( p1, v21 ) / dot2( v21 ), 0.0, 1.0 );\n\t\tw = 0.0;\n\t\tu = 1.0-v;\n\n\t}\n\n\tbarycoord = vec3( u, v, w );\n    return u * v1 + v * v2 + w * v0;\n\n}\n\nfloat distanceToTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// point and cut off range\n\tvec3 point, float closestDistanceSquared,\n\n\t// outputs\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord, inout float side, inout vec3 outPoint\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\t// get the closest point and barycoord\n\t\tvec3 closestPoint = closestPointToTriangle( point, a, b, c, localBarycoord );\n\t\tvec3 delta = point - closestPoint;\n\t\tfloat sqDist = dot2( delta );\n\t\tif ( sqDist < closestDistanceSquared ) {\n\n\t\t\t// set the output results\n\t\t\tclosestDistanceSquared = sqDist;\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = normalize( cross( a - b, b - c ) );\n\t\t\tbarycoord = localBarycoord;\n\t\t\toutPoint = closestPoint;\n\t\t\tside = sign( dot( faceNormal, delta ) );\n\n\t\t}\n\n\t}\n\n\treturn closestDistanceSquared;\n\n}\n\nfloat distanceSqToBounds( vec3 point, vec3 boundsMin, vec3 boundsMax ) {\n\n\tvec3 clampedPoint = clamp( point, boundsMin, boundsMax );\n\tvec3 delta = point - clampedPoint;\n\treturn dot( delta, delta );\n\n}\n\nfloat distanceSqToBVHNodeBoundsPoint( vec3 point, sampler2D bvhBounds, uint currNodeIndex ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn distanceSqToBounds( point, boundsMin, boundsMax );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhClosestPointToPoint(\\\n\t\tbvh,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\\\n\t_bvhClosestPointToPoint(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\tpoint, maxDistance, faceIndices, faceNormal, barycoord, side, outPoint\\\n\t)\n\nfloat _bvhClosestPointToPoint(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// point to check\n\tvec3 point, float maxDistance,\n\n\t// output variables\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout vec3 outPoint\n ) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat closestDistanceSquared = maxDistance * maxDistance;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, currNodeIndex );\n\t\tif ( boundsHitDistance > closestDistanceSquared ) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\t\t\tclosestDistanceSquared = distanceToTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count, point, closestDistanceSquared,\n\n\t\t\t\t// outputs\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, outPoint\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\t\t\tbool leftToRight = distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, leftIndex ) < distanceSqToBVHNodeBoundsPoint( point, bvh_bvhBounds, rightIndex );//rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn sqrt( closestDistanceSquared );\n\n}\n`;\n","export const bvh_ray_functions = /* glsl */`\n\n#ifndef TRI_INTERSECT_EPSILON\n#define TRI_INTERSECT_EPSILON 1e-5\n#endif\n\n// Raycasting\nbool intersectsBounds( vec3 rayOrigin, vec3 rayDirection, vec3 boundsMin, vec3 boundsMax, out float dist ) {\n\n\t// https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\n\t// https://tavianator.com/2011/ray_box.html\n\tvec3 invDir = 1.0 / rayDirection;\n\n\t// find intersection distances for each plane\n\tvec3 tMinPlane = invDir * ( boundsMin - rayOrigin );\n\tvec3 tMaxPlane = invDir * ( boundsMax - rayOrigin );\n\n\t// get the min and max distances from each intersection\n\tvec3 tMinHit = min( tMaxPlane, tMinPlane );\n\tvec3 tMaxHit = max( tMaxPlane, tMinPlane );\n\n\t// get the furthest hit distance\n\tvec2 t = max( tMinHit.xx, tMinHit.yz );\n\tfloat t0 = max( t.x, t.y );\n\n\t// get the minimum hit distance\n\tt = min( tMaxHit.xx, tMaxHit.yz );\n\tfloat t1 = min( t.x, t.y );\n\n\t// set distance to 0.0 if the ray starts inside the box\n\tdist = max( t0, 0.0 );\n\n\treturn t1 >= dist;\n\n}\n\nbool intersectsTriangle(\n\tvec3 rayOrigin, vec3 rayDirection, vec3 a, vec3 b, vec3 c,\n\tout vec3 barycoord, out vec3 norm, out float dist, out float side\n) {\n\n\t// https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\n\tvec3 edge1 = b - a;\n\tvec3 edge2 = c - a;\n\tnorm = cross( edge1, edge2 );\n\n\tfloat det = - dot( rayDirection, norm );\n\tfloat invdet = 1.0 / det;\n\n\tvec3 AO = rayOrigin - a;\n\tvec3 DAO = cross( AO, rayDirection );\n\n\tvec4 uvt;\n\tuvt.x = dot( edge2, DAO ) * invdet;\n\tuvt.y = - dot( edge1, DAO ) * invdet;\n\tuvt.z = dot( AO, norm ) * invdet;\n\tuvt.w = 1.0 - uvt.x - uvt.y;\n\n\t// set the hit information\n\tbarycoord = uvt.wxy; // arranged in A, B, C order\n\tdist = uvt.z;\n\tside = sign( det );\n\tnorm = side * normalize( norm );\n\n\t// add an epsilon to avoid misses between triangles\n\tuvt += vec4( TRI_INTERSECT_EPSILON );\n\n\treturn all( greaterThanEqual( uvt, vec4( 0.0 ) ) );\n\n}\n\nbool intersectTriangles(\n\t// geometry info and triangle range\n\tsampler2D positionAttr, usampler2D indexAttr, uint offset, uint count,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// outputs\n\tinout float minDistance, inout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\tbool found = false;\n\tvec3 localBarycoord, localNormal;\n\tfloat localDist, localSide;\n\tfor ( uint i = offset, l = offset + count; i < l; i ++ ) {\n\n\t\tuvec3 indices = uTexelFetch1D( indexAttr, i ).xyz;\n\t\tvec3 a = texelFetch1D( positionAttr, indices.x ).rgb;\n\t\tvec3 b = texelFetch1D( positionAttr, indices.y ).rgb;\n\t\tvec3 c = texelFetch1D( positionAttr, indices.z ).rgb;\n\n\t\tif (\n\t\t\tintersectsTriangle( rayOrigin, rayDirection, a, b, c, localBarycoord, localNormal, localDist, localSide )\n\t\t\t&& localDist < minDistance\n\t\t) {\n\n\t\t\tfound = true;\n\t\t\tminDistance = localDist;\n\n\t\t\tfaceIndices = uvec4( indices.xyz, i );\n\t\t\tfaceNormal = localNormal;\n\n\t\t\tside = localSide;\n\t\t\tbarycoord = localBarycoord;\n\t\t\tdist = localDist;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n\nbool intersectsBVHNodeBounds( vec3 rayOrigin, vec3 rayDirection, sampler2D bvhBounds, uint currNodeIndex, out float dist ) {\n\n\tuint cni2 = currNodeIndex * 2u;\n\tvec3 boundsMin = texelFetch1D( bvhBounds, cni2 ).xyz;\n\tvec3 boundsMax = texelFetch1D( bvhBounds, cni2 + 1u ).xyz;\n\treturn intersectsBounds( rayOrigin, rayDirection, boundsMin, boundsMax, dist );\n\n}\n\n// use a macro to hide the fact that we need to expand the struct into separate fields\n#define\\\n\tbvhIntersectFirstHit(\\\n\t\tbvh,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\\\n\t_bvhIntersectFirstHit(\\\n\t\tbvh.position, bvh.index, bvh.bvhBounds, bvh.bvhContents,\\\n\t\trayOrigin, rayDirection, faceIndices, faceNormal, barycoord, side, dist\\\n\t)\n\nbool _bvhIntersectFirstHit(\n\t// bvh info\n\tsampler2D bvh_position, usampler2D bvh_index, sampler2D bvh_bvhBounds, usampler2D bvh_bvhContents,\n\n\t// ray\n\tvec3 rayOrigin, vec3 rayDirection,\n\n\t// output variables split into separate variables due to output precision\n\tinout uvec4 faceIndices, inout vec3 faceNormal, inout vec3 barycoord,\n\tinout float side, inout float dist\n) {\n\n\t// stack needs to be twice as long as the deepest tree we expect because\n\t// we push both the left and right child onto the stack every traversal\n\tint ptr = 0;\n\tuint stack[ BVH_STACK_DEPTH ];\n\tstack[ 0 ] = 0u;\n\n\tfloat triangleDistance = INFINITY;\n\tbool found = false;\n\twhile ( ptr > - 1 && ptr < BVH_STACK_DEPTH ) {\n\n\t\tuint currNodeIndex = stack[ ptr ];\n\t\tptr --;\n\n\t\t// check if we intersect the current bounds\n\t\tfloat boundsHitDistance;\n\t\tif (\n\t\t\t! intersectsBVHNodeBounds( rayOrigin, rayDirection, bvh_bvhBounds, currNodeIndex, boundsHitDistance )\n\t\t\t|| boundsHitDistance > triangleDistance\n\t\t) {\n\n\t\t\tcontinue;\n\n\t\t}\n\n\t\tuvec2 boundsInfo = uTexelFetch1D( bvh_bvhContents, currNodeIndex ).xy;\n\t\tbool isLeaf = bool( boundsInfo.x & 0xffff0000u );\n\n\t\tif ( isLeaf ) {\n\n\t\t\tuint count = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint offset = boundsInfo.y;\n\n\t\t\tfound = intersectTriangles(\n\t\t\t\tbvh_position, bvh_index, offset, count,\n\t\t\t\trayOrigin, rayDirection, triangleDistance,\n\t\t\t\tfaceIndices, faceNormal, barycoord, side, dist\n\t\t\t) || found;\n\n\t\t} else {\n\n\t\t\tuint leftIndex = currNodeIndex + 1u;\n\t\t\tuint splitAxis = boundsInfo.x & 0x0000ffffu;\n\t\t\tuint rightIndex = boundsInfo.y;\n\n\t\t\tbool leftToRight = rayDirection[ splitAxis ] >= 0.0;\n\t\t\tuint c1 = leftToRight ? leftIndex : rightIndex;\n\t\t\tuint c2 = leftToRight ? rightIndex : leftIndex;\n\n\t\t\t// set c2 in the stack so we traverse it later. We need to keep track of a pointer in\n\t\t\t// the stack while we traverse. The second pointer added is the one that will be\n\t\t\t// traversed first\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c2;\n\n\t\t\tptr ++;\n\t\t\tstack[ ptr ] = c1;\n\n\t\t}\n\n\t}\n\n\treturn found;\n\n}\n`;\n","// Note that a struct cannot be used for the hit record including faceIndices, faceNormal, barycoord,\n// side, and dist because on some mobile GPUS (such as Adreno) numbers are afforded less precision specifically\n// when in a struct leading to inaccurate hit results. See KhronosGroup/WebGL#3351 for more details.\nexport const bvh_struct_definitions = /* glsl */`\nstruct BVH {\n\n\tusampler2D index;\n\tsampler2D position;\n\n\tsampler2D bvhBounds;\n\tusampler2D bvhContents;\n\n};\n`;\n","export { MeshBVH } from './core/MeshBVH.js';\nexport { MeshBVHHelper } from './objects/MeshBVHHelper.js';\nexport { CENTER, AVERAGE, SAH, NOT_INTERSECTED, INTERSECTED, CONTAINED } from './core/Constants.js';\nexport { getBVHExtremes, estimateMemoryInBytes, getJSONStructure, validateBounds } from './debug/Debug.js';\nexport * from './utils/ExtensionUtilities.js';\nexport { getTriangleHitPointInfo } from './utils/TriangleUtilities.js';\nexport * from './math/ExtendedTriangle.js';\nexport * from './math/OrientedBox.js';\nexport * from './gpu/MeshBVHUniformStruct.js';\nexport * from './gpu/VertexAttributeTexture.js';\nexport * from './utils/StaticGeometryGenerator.js';\nexport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\n\n// backwards compatibility\nimport * as BVHShaderGLSL from './gpu/BVHShaderGLSL.js';\nexport const shaderStructs = BVHShaderGLSL.bvh_struct_definitions;\nexport const shaderDistanceFunction = BVHShaderGLSL.bvh_distance_functions;\nexport const shaderIntersectFunction = `\n\t${ BVHShaderGLSL.common_functions }\n\t${ BVHShaderGLSL.bvh_ray_functions }\n`;\n"],"names":["j","root","l","matrix","offset","BVHShaderGLSL.bvh_struct_definitions","BVHShaderGLSL.bvh_distance_functions","BVHShaderGLSL.common_functions","BVHShaderGLSL.bvh_ray_functions"],"mappings":"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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACCnC,MAAM;AAAA;AAAA,EAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACDzC,MAAM;AAAA;AAAA,EAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ACGpC,MAAM;AAAA;AAAA,EAAmC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;ACYpC,MAAC,gBAAgBG;AACjB,MAAC,yBAAyBC;AAC1B,MAAC,0BAA0B;AAAA,GACnCC,gBAA8B;AAAA,GAC9BC,iBAA+B;AAAA;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}