{"version":3,"file":"index-kS-0OvAt.js","sources":["../../frontend/node_modules/@needle-tools/three-animation-pointer/src/GLTFLoaderAnimationPointer.js"],"sourcesContent":["import {\n\tAnimationClip,\n\tColorKeyframeTrack,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNumberKeyframeTrack,\n\tPropertyBinding,\n\tQuaternionKeyframeTrack,\n\tVectorKeyframeTrack,\n\tSkinnedMesh,\n\tBooleanKeyframeTrack\n} from 'three';\n\n/** \n * @typedef {import(\"..\").GLTFAnimationPointerExtension} PluginType \n */\n\n// DUPLICATED from GLTFLoader.js\nconst ANIMATION_TARGET_TYPE = {\n\tnode: 'node',\n\tmaterial: 'material',\n\tcamera: 'camera',\n\tlight: 'light',\n};\n\nconst KHR_ANIMATION_POINTER = 'KHR_animation_pointer';\n\n// DUPLICATED from GLTFLoader.js\nconst INTERPOLATION = {\n\t// We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\n\t// keyframe track will be initialized with a default interpolation type, then modified.\n\tCUBICSPLINE: undefined,\n\tLINEAR: InterpolateLinear,\n\tSTEP: InterpolateDiscrete\n};\n\nconst _animationPointerDebug = false;\n\n\n/**\n * Animation Pointer Extension\n *\n * Draft Specification: https://github.com/ux3d/glTF/tree/extensions/KHR_animation_pointer/extensions/2.0/Khronos/KHR_animation_pointer\n * \n * @implements {PluginType}\n */\nexport class GLTFAnimationPointerExtension {\n\n\t/** @type {import(\"three/examples/jsm/loaders/GLTFLoader\").GLTFParser} */\n\tconstructor( parser ) {\n\n\t\tthis.name = KHR_ANIMATION_POINTER;\n\t\tthis.parser = parser;\n\n\t\t/** @type {import(\"..\").AnimationPointerResolver | null} */\n\t\tthis.animationPointerResolver = null;\n\n\t}\n\n\t/** \n\t * @param {import(\"..\").AnimationPointerResolver | null} animationPointerResolver\n\t */\n\tsetAnimationPointerResolver( animationPointerResolver ) {\n\n\t\tthis.animationPointerResolver = animationPointerResolver;\n\t\treturn this;\n\n\t}\n\n\t/* DUPLICATE of functionality in GLTFLoader */\n\tloadAnimationTargetFromChannel( animationChannel ) {\n\n\t\tconst target = animationChannel.target;\n\t\tconst name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\treturn this.parser.getDependency( 'node', name );\n\n\t}\n\n\tloadAnimationTargetFromChannelWithAnimationPointer( animationChannel ) {\n\n\t\t_ensurePropertyBindingPatch();\n\n\t\tconst target = animationChannel.target;\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\n\t\tif ( ! useExtension ) return null;\n\n\t\tlet targetProperty = undefined;\n\n\t\t// check if this is a extension animation\n\t\tlet type = ANIMATION_TARGET_TYPE.node;\n\t\tlet targetId = undefined;\n\n\t\tif ( useExtension ) {\n\n\t\t\tconst ext = target.extensions[ KHR_ANIMATION_POINTER ];\n\t\t\tlet path = ext.pointer;\n\t\t\tif ( _animationPointerDebug )\n\t\t\t\tconsole.log( 'Original path: ' + path, target );\n\n\t\t\tif ( ! path ) {\n\n\t\t\t\tconsole.warn( 'Invalid path', ext, target );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( path.startsWith( '/materials/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.material;\n\t\t\telse if ( path.startsWith( '/extensions/KHR_lights_punctual/lights/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.light;\n\t\t\telse if ( path.startsWith( '/cameras/' ) )\n\t\t\t\ttype = ANIMATION_TARGET_TYPE.camera;\n\n\t\t\ttargetId = this._tryResolveTargetId( path, type );\n\t\t\tif ( targetId === null || isNaN( targetId ) ) {\n\n\t\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, path );\n\t\t\t\treturn;\n\n\t\t\t} else {\n\n\t\t\t\tif ( _animationPointerDebug ) console.log( 'Resolved node ID for ' + type, targetId );\n\n\t\t\t}\n\n\t\t\t// TODO could be parsed better\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.material:\n\t\t\t\t\tconst pathIndex = ( '/materials/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStart = path.substring( 0, pathIndex );\n\t\t\t\t\ttargetProperty = path.substring( pathIndex );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\t// Core Spec PBR Properties\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'color';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/roughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'roughness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/metallicFactor':\n\t\t\t\t\t\t\ttargetProperty = 'metalness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emissiveFactor':\n\t\t\t\t\t\t\ttargetProperty = 'emissive';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'alphaCutoff':\n\t\t\t\t\t\t\ttargetProperty = 'alphaTest';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'occlusionTexture/strength':\n\t\t\t\t\t\t\ttargetProperty = 'aoMapIntensity';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'normalTexture/scale':\n\t\t\t\t\t\t\ttargetProperty = 'normalScale';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// Core Spec + KHR_texture_transform\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/scale':\n\t\t\t\t\t\t\ttargetProperty = 'map/repeat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'pbrMetallicRoughness/baseColorTexture/extensions/KHR_texture_transform/offset':\n\t\t\t\t\t\t\ttargetProperty = 'map/offset';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// UV transforms for anything but map doesn't seem to currently be supported in three.js\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/scale':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/repeat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'emissiveTexture/extensions/KHR_texture_transform/offset':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveMap/offset';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_emissive_strength\n\t\t\t\t\t\tcase 'extensions/KHR_materials_emissive_strength/emissiveStrength':\n\t\t\t\t\t\t\ttargetProperty = 'emissiveIntensity';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_transmission\n\t\t\t\t\t\tcase 'extensions/KHR_materials_transmission/transmissionFactor':\n\t\t\t\t\t\t\ttargetProperty = 'transmission';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_ior\n\t\t\t\t\t\tcase 'extensions/KHR_materials_ior/ior':\n\t\t\t\t\t\t\ttargetProperty = 'ior';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_volume\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/thicknessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'thickness';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationColor':\n\t\t\t\t\t\t\ttargetProperty = 'attenuationColor';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_volume/attenuationDistance':\n\t\t\t\t\t\t\ttargetProperty = 'attenuationDistance';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_iridescence\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceFactor':\n\t\t\t\t\t\t\ttargetProperty = 'iridescence';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceIor':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceIOR';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMinimum':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[0]';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_iridescence/iridescenceThicknessMaximum':\n\t\t\t\t\t\t\ttargetProperty = 'iridescenceThicknessRange[1]';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_clearcoat\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatFactor':\n\t\t\t\t\t\t\ttargetProperty = 'clearcoat';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_clearcoat/clearcoatRoughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'clearcoatRoughness';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_sheen\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'sheenColor';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_sheen/sheenRoughnessFactor':\n\t\t\t\t\t\t\ttargetProperty = 'sheenRoughness';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t// KHR_materials_specular\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularFactor':\n\t\t\t\t\t\t\ttargetProperty = 'specularIntensity';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'extensions/KHR_materials_specular/specularColorFactor':\n\t\t\t\t\t\t\ttargetProperty = 'specularColor';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStart + targetProperty;\n\t\t\t\t\tif ( _animationPointerDebug ) console.log( 'PROPERTY PATH', pathStart, targetProperty, path );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.node:\n\t\t\t\t\tconst pathIndexNode = ( '/nodes/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStartNode = path.substring( 0, pathIndexNode );\n\t\t\t\t\ttargetProperty = path.substring( pathIndexNode );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'translation':\n\t\t\t\t\t\t\ttargetProperty = 'position';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'rotation':\n\t\t\t\t\t\t\ttargetProperty = 'quaternion';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\ttargetProperty = 'scale';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'weights':\n\t\t\t\t\t\t\ttargetProperty = 'morphTargetInfluences';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"KHR_node_visibility/visible\":\n\t\t\t\t\t\t\ttargetProperty = 'visible';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStartNode + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.light:\n\t\t\t\t\tconst pathIndexLight = ( '/extensions/KHR_lights_punctual/lights/' + targetId.toString() + '/' ).length;\n\t\t\t\t\ttargetProperty = path.substring( pathIndexLight );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'color':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'intensity':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'spot/innerConeAngle':\n\t\t\t\t\t\t\t// TODO would need to set .penumbra, but requires calculations on every animation change (?)\n\t\t\t\t\t\t\ttargetProperty = 'penumbra';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'spot/outerConeAngle':\n\t\t\t\t\t\t\ttargetProperty = 'angle';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'range':\n\t\t\t\t\t\t\ttargetProperty = 'distance';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = '/lights/' + targetId.toString() + '/' + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ANIMATION_TARGET_TYPE.camera:\n\t\t\t\t\tconst pathIndexCamera = ( '/cameras/' + targetId.toString() + '/' ).length;\n\t\t\t\t\tconst pathStartCamera = path.substring( 0, pathIndexCamera );\n\t\t\t\t\ttargetProperty = path.substring( pathIndexCamera );\n\n\t\t\t\t\tswitch ( targetProperty ) {\n\n\t\t\t\t\t\tcase 'perspective/yfov':\n\t\t\t\t\t\t\ttargetProperty = 'fov';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/znear':\n\t\t\t\t\t\tcase 'orthographic/znear':\n\t\t\t\t\t\t\ttargetProperty = 'near';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/zfar':\n\t\t\t\t\t\tcase 'orthographic/zfar':\n\t\t\t\t\t\t\ttargetProperty = 'far';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'perspective/aspect':\n\t\t\t\t\t\t\ttargetProperty = 'aspect';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t// these two write to the same target property since three.js orthographic camera only supports 'zoom'.\n\t\t\t\t\t\t// TODO should there be a warning for either of them? E.g. a warning for \"xmag\" so that \"yfov\" + \"ymag\" work by default?\n\t\t\t\t\t\tcase 'orthographic/xmag':\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'orthographic/ymag':\n\t\t\t\t\t\t\ttargetProperty = 'zoom';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpath = pathStartCamera + targetProperty;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( this.animationPointerResolver?.resolvePath ) {\n\n\t\t\t\tpath = this.animationPointerResolver.resolvePath( path );\n\n\t\t\t}\n\n\t\t\ttarget.extensions[ KHR_ANIMATION_POINTER ].pointer = path;\n\n\t\t}\n\n\t\tif ( targetId === null || targetId === undefined || isNaN( targetId ) ) {\n\n\t\t\tconsole.warn( 'Failed resolving animation node id: ' + targetId, target );\n\t\t\treturn;\n\n\t\t}\n\n\t\tlet depPromise;\n\n\t\tif ( type === ANIMATION_TARGET_TYPE.node )\n\t\t\tdepPromise = this.parser.getDependency( 'node', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.material )\n\t\t\tdepPromise = this.parser.getDependency( 'material', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.light )\n\t\t\tdepPromise = this.parser.getDependency( 'light', targetId );\n\t\telse if ( type === ANIMATION_TARGET_TYPE.camera )\n\t\t\tdepPromise = this.parser.getDependency( 'camera', targetId );\n\t\telse\n\t\t\tconsole.error( 'Unhandled type', type );\n\n\t\treturn depPromise;\n\n\t}\n\n\tcreateAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target ) {\n\n\t\tconst useExtension = target.extensions && target.extensions[ KHR_ANIMATION_POINTER ] && target.path && target.path === 'pointer';\n\t\tif ( ! useExtension ) return null;\n\n\t\tlet animationPointerPropertyPath = target.extensions[ KHR_ANIMATION_POINTER ].pointer;\n\t\tif ( ! animationPointerPropertyPath ) return null;\n\n\t\tconst tracks = [];\n\n\t\tanimationPointerPropertyPath = animationPointerPropertyPath.replaceAll( '/', '.' );\n\t\t// replace node/material/camera/light ID by UUID\n\t\tconst parts = animationPointerPropertyPath.split( '.' );\n\t\tconst hasName = node.name !== undefined && node.name !== null;\n\t\tvar nodeTargetName = hasName ? node.name : node.uuid;\n\t\tparts[ 2 ] = nodeTargetName;\n\n\t\t// specially handle the morphTargetInfluences property for multi-material meshes\n\t\t// in which case the target object is a Group and the children are the actual targets\n\t\t// see NE-3311\n\t\tif ( parts[ 3 ] === 'morphTargetInfluences' ) {\n\n\t\t\tif ( node.type === 'Group' ) {\n\n\t\t\t\tif ( _animationPointerDebug )\n\t\t\t\t\tconsole.log( 'Detected multi-material skinnedMesh export', animationPointerPropertyPath, node );\n\n\t\t\t\t// We assume the children are skinned meshes\n\t\t\t\tfor ( const ch of node.children ) {\n\n\t\t\t\t\tif ( ch instanceof SkinnedMesh && ch.morphTargetInfluences ) {\n\n\t\t\t\t\t\tparts[ 3 ] = ch.name;\n\t\t\t\t\t\tparts[ 4 ] = 'morphTargetInfluences';\n\t\t\t\t\t\t__createTrack( this.parser );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn tracks;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// default\n\t\t__createTrack( this.parser );\n\n\n\t\tfunction isBooleanTarget(node, trackPath)  {\n\t\t// trackPath like \".nodes.MyNode.visible\" or \".materials.<uuid>.wireframe\"\n\t\ttry {\n\t\n\t\t\t// get last token after '.'\n\t\t\tconst sections = trackPath.split('.').filter(Boolean);\n\t\t\tlet last = sections[sections.length - 1]; // e.g., 'visible' or 'iridescenceThicknessRange[0]'\n\t\t\n\t\t\t// strip indexers like [0]\n\t\t\tconst propName = last.replace(/\\[.*\\]$/, '');\n\t\t\n\t\t\t// bail if not a direct property\n\t\t\tif (!(propName in node)) return false;\n\n\t\t\tconst val = node[propName];\n\t\t\treturn typeof val === 'boolean';\n\t\t} \n\t\tcatch {\n\t\t\treturn false;\n\t\t}\n\t\t}\n\n\t\t/** Create a new track using the current parts array */\n\t\tfunction __createTrack( parser ) {\n\n\t\t\tanimationPointerPropertyPath = parts.join( '.' );\n\n\t\t\tif ( _animationPointerDebug )\n\t\t\t\tconsole.log( node, inputAccessor, outputAccessor, target, animationPointerPropertyPath );\n\n\t\t\tlet TypedKeyframeTrack;\n\t\t\tlet convertToBoolean = false;\n\t\t\tswitch ( outputAccessor.itemSize ) {\n\n\t\t\t\tcase 1: \n\t\t\t\t\t// Get type of outputAccessor.array elements\n\t\t\t\t\tconst arrayType = Object.prototype.toString.call(outputAccessor.array);\n\t\t\t\t\tconst isUInt8 = (arrayType === '[object Uint8Array]');\n\n\t\t\t\t\tconst looksLikeBool = isUInt8 && // UNSIGNED_BYTE as a strong hint\n\t\t\t\t\t\tisBooleanTarget(node, animationPointerPropertyPath);\n\t\t\t\t\tif (looksLikeBool) {\n\t\t\t\t\t\tTypedKeyframeTrack = BooleanKeyframeTrack;\n\t\t\t\t\t\tconvertToBoolean = true; // map 0 => false, >0 => true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tTypedKeyframeTrack = NumberKeyframeTrack;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\tcase 3:\n\t\t\t\t\tTypedKeyframeTrack = VectorKeyframeTrack;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\n\t\t\t\t\tif ( animationPointerPropertyPath.endsWith( '.quaternion' ) )\n\t\t\t\t\t\tTypedKeyframeTrack = QuaternionKeyframeTrack;\n\t\t\t\t\telse\n\t\t\t\t\t\tTypedKeyframeTrack = ColorKeyframeTrack;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif( !TypedKeyframeTrack ) {\n\t\t\t\tconsole.warn( 'Unsupported output accessor format', outputAccessor );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;\n\n\t\t\tlet outputArray = parser._getArrayFromAccessor( outputAccessor );\n\n\t\t\t// convert fov values from radians to degrees\n\t\t\tif ( animationPointerPropertyPath.endsWith( '.fov' ) ) {\n\n\t\t\t\toutputArray = outputArray.map( value => value / Math.PI * 180 );\n\t\t\t}\n\n\t\t\tif (convertToBoolean) {\n\t\t\t\t// boolean values are stored as ubyte in glTF, 0 = false, anything else = true \n\t\t\t\toutputArray = outputArray.map( v => v > 0 );\n\t\t\t}\n\n\t\t\tconst track = new TypedKeyframeTrack(\n\t\t\t\tanimationPointerPropertyPath,\n\t\t\t\tinputAccessor.array,\n\t\t\t\toutputArray,\n\t\t\t\tinterpolation\n\t\t\t);\n\n\t\t\t// Override interpolation with custom factory method.\n\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\n\n\t\t\t}\n\n\t\t\ttracks.push( track );\n\n\t\t\t// glTF has opacity animation as last component of baseColorFactor,\n\t\t\t// so we need to split that up here and create a separate opacity track if that is animated.\n\t\t\tif ( animationPointerPropertyPath && outputAccessor.itemSize === 4 &&\n\t\t\t\tanimationPointerPropertyPath.startsWith( '.materials.' ) && animationPointerPropertyPath.endsWith( '.color' ) ) {\n\n\t\t\t\tconst opacityArray = new Float32Array( outputArray.length / 4 );\n\n\t\t\t\tfor ( let j = 0, jl = outputArray.length / 4; j < jl; j += 1 ) {\n\n\t\t\t\t\topacityArray[ j ] = outputArray[ j * 4 + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tconst opacityTrack = new TypedKeyframeTrack(\n\t\t\t\t\tanimationPointerPropertyPath.replace( '.color', '.opacity' ),\n\t\t\t\t\tinputAccessor.array,\n\t\t\t\t\topacityArray,\n\t\t\t\t\tinterpolation\n\t\t\t\t);\n\n\t\t\t\t// Override interpolation with custom factory method.\n\t\t\t\tif ( interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\tparser._createCubicSplineTrackInterpolant( track );\n\n\t\t\t\t}\n\n\t\t\t\ttracks.push( opacityTrack );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn tracks;\n\n\t}\n\n\t_tryResolveTargetId( path, type ) {\n\n\t\tlet name = '';\n\t\tif ( type === 'node' ) {\n\n\t\t\tname = path.substring( '/nodes/'.length );\n\n\t\t} else if ( type === 'material' ) {\n\n\t\t\tname = path.substring( '/materials/'.length );\n\n\t\t} else if ( type === 'light' ) {\n\n\t\t\tname = path.substring( '/extensions/KHR_lights_punctual/lights/'.length );\n\n\t\t} else if ( type === 'camera' ) {\n\n\t\t\tname = path.substring( '/cameras/'.length );\n\n\t\t}\n\n\t\tname = name.substring( 0, name.indexOf( '/' ) );\n\t\tconst index = Number.parseInt( name );\n\t\treturn index;\n\n\t}\n\n\t/* MOSTLY DUPLICATE of GLTFLoader.loadAnimation, but also tries to resolve KHR_animation_pointer. */\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<AnimationClip>}\n\t */\n\tloadAnimation( animationIndex ) {\n\n\t\tconst me = this;\n\t\tconst json = this.parser.json;\n\t\tconst parser = this.parser;\n\n\t\tconst animationDef = json.animations[ animationIndex ];\n\t\tconst animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;\n\n\t\tconst pendingNodes = [];\n\t\tconst pendingInputAccessors = [];\n\t\tconst pendingOutputAccessors = [];\n\t\tconst pendingSamplers = [];\n\t\tconst pendingTargets = [];\n\n\t\tfor ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\tconst channel = animationDef.channels[ i ];\n\t\t\tconst sampler = animationDef.samplers[ channel.sampler ];\n\t\t\tconst target = channel.target;\n\t\t\tconst input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\tconst output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\tlet nodeDependency = me.loadAnimationTargetFromChannelWithAnimationPointer( channel );\n\t\t\tif ( ! nodeDependency )\n\t\t\t\tnodeDependency = me.loadAnimationTargetFromChannel( channel );\n\n\t\t\tpendingNodes.push( nodeDependency );\n\t\t\tpendingInputAccessors.push( parser.getDependency( 'accessor', input ) );\n\t\t\tpendingOutputAccessors.push( parser.getDependency( 'accessor', output ) );\n\t\t\tpendingSamplers.push( sampler );\n\t\t\tpendingTargets.push( target );\n\n\t\t}\n\n\t\treturn Promise.all( [\n\n\t\t\tPromise.all( pendingNodes ),\n\t\t\tPromise.all( pendingInputAccessors ),\n\t\t\tPromise.all( pendingOutputAccessors ),\n\t\t\tPromise.all( pendingSamplers ),\n\t\t\tPromise.all( pendingTargets )\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tconst nodes = dependencies[ 0 ];\n\t\t\tconst inputAccessors = dependencies[ 1 ];\n\t\t\tconst outputAccessors = dependencies[ 2 ];\n\t\t\tconst samplers = dependencies[ 3 ];\n\t\t\tconst targets = dependencies[ 4 ];\n\n\t\t\tconst tracks = [];\n\n\t\t\tfor ( let i = 0, il = nodes.length; i < il; i ++ ) {\n\n\t\t\t\tconst node = nodes[ i ];\n\t\t\t\tconst inputAccessor = inputAccessors[ i ];\n\t\t\t\tconst outputAccessor = outputAccessors[ i ];\n\t\t\t\tconst sampler = samplers[ i ];\n\t\t\t\tconst target = targets[ i ];\n\n\t\t\t\tif ( node === undefined ) continue;\n\n\t\t\t\tif ( node.updateMatrix ) {\n\n\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t}\n\n\t\t\t\tlet createdTracks = me.createAnimationTracksWithAnimationPointer( node, inputAccessor, outputAccessor, sampler, target );\n\t\t\t\tif ( ! createdTracks )\n\t\t\t\t\tcreatedTracks = parser._createAnimationTracks( node, inputAccessor, outputAccessor, sampler, target );\n\n\t\t\t\tif ( createdTracks ) {\n\n\t\t\t\t\tfor ( let k = 0; k < createdTracks.length; k ++ ) {\n\n\t\t\t\t\t\ttracks.push( createdTracks[ k ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( animationName, undefined, tracks );\n\n\t\t} );\n\n\t}\n\n}\n\n\n\nlet _havePatchedPropertyBindings = false;\n\n// HACK monkey patching findNode to ensure we can map to other types required by KHR_animation_pointer.\n/** @type {PropertyBinding.findNode | null} */\nlet findNodeFn = null;\n\nfunction _ensurePropertyBindingPatch() {\n\n\tif (_havePatchedPropertyBindings) return;\n\t_havePatchedPropertyBindings = true;\n\n\tconst findNode = (findNodeFn ||= PropertyBinding.findNode);\n\n\t// \"node\" is the Animator component in our case\n\t// \"path\" is the animated property path, just with translated material names.\n\tPropertyBinding.findNode = function (node, path) {\n\n\t\t// if the binding is empty fallback to original\n\t\tif (!path) return findNode(node, path);\n\n\n\t\tif (path.startsWith('.materials.')) {\n\n\t\t\tif (_animationPointerDebug) console.log('FIND', path);\n\n\t\t\tconst remainingPath = path.substring('.materials.'.length).substring(path.indexOf('.'));\n\t\t\tconst nextIndex = remainingPath.indexOf('.');\n\t\t\tconst uuid = nextIndex < 0 ? remainingPath : remainingPath.substring(0, nextIndex);\n\t\t\tlet res = null;\n\t\t\tnode.traverse(x => {\n\n\t\t\t\tif (res !== null || (x.type !== 'Mesh' && x.type !== 'SkinnedMesh')) return;\n\t\t\t\tif (x['material'] && (x['material'].uuid === uuid || x['material'].name === uuid)) {\n\n\t\t\t\t\tres = x['material'];\n\t\t\t\t\tif (_animationPointerDebug) console.log(res, remainingPath);\n\t\t\t\t\tif (res !== null) {\n\n\t\t\t\t\t\tif (remainingPath.endsWith('.map'))\n\t\t\t\t\t\t\tres = res['map'];\n\t\t\t\t\t\telse if (remainingPath.endsWith('.emissiveMap'))\n\t\t\t\t\t\t\tres = res['emissiveMap'];\n\n\t\t\t\t\t\t// TODO other texture slots only make sense if three.js actually supports them\n\t\t\t\t\t\t// (currently only .map can have repeat/offset)\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t\treturn res;\n\n\t\t} else if (path.startsWith('.nodes.') || path.startsWith('.lights.') || path.startsWith('.cameras.')) {\n\n\t\t\tconst sections = path.split('.');\n\t\t\tlet currentTarget = undefined;\n\t\t\tfor (let i = 1; i < sections.length; i++) {\n\n\t\t\t\tconst val = sections[i];\n\t\t\t\tconst isUUID = val.length == 36;\n\t\t\t\tif (isUUID) {\n\n\t\t\t\t\t// access by UUID\n\t\t\t\t\tcurrentTarget = node.getObjectByProperty('uuid', val);\n\n\t\t\t\t} else if (currentTarget && currentTarget[val]) {\n\n\t\t\t\t\t// access by index\n\t\t\t\t\tconst index = Number.parseInt(val);\n\t\t\t\t\t/** @type {string|number} */\n\t\t\t\t\tlet key = val;\n\t\t\t\t\tif (index >= 0) key = index;\n\t\t\t\t\tcurrentTarget = currentTarget[key];\n\t\t\t\t\tif (_animationPointerDebug)\n\t\t\t\t\t\tconsole.log(currentTarget);\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// access by node name\n\t\t\t\t\tconst foundNode = node.getObjectByName(val);\n\n\t\t\t\t\tif (foundNode)\n\t\t\t\t\t\tcurrentTarget = foundNode;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!currentTarget) {\n\n\t\t\t\tconst originalFindResult = findNode(node, sections[2]);\n\n\t\t\t\tif (!originalFindResult)\n\t\t\t\t\tconsole.warn(KHR_ANIMATION_POINTER + ': Property binding not found', path, node, node.name, sections);\n\n\t\t\t\treturn originalFindResult;\n\n\t\t\t}\n\n\t\t\tif (_animationPointerDebug)\n\t\t\t\tconsole.log('NODE', path, currentTarget);\n\n\t\t\treturn currentTarget;\n\n\t\t}\n\n\t\treturn findNode(node, path);\n\n\t};\n\n}"],"names":["node"],"mappings":"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","x_google_ignoreList":[0]}